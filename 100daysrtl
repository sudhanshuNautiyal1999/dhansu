1) 3 to 8 decoder
module decoder3X8(in,out);
input [2:0] in;
output [7:0] out;
reg [7:0]out;
always @(*)
begin
case (in)
3'b000: out=8'b00000001;
3'b001: out=8'b00000010;
3'b010: out=8'b00000100;
3'b011: out=8'b00001000;
3'b100: out=8'b00010000;
3'b101: out=8'b00100000;
3'b110: out=8'b01000000;
3'b111: out=8'b10000000;
default : out=8'b00000000;

endcase

end

endmodule
module test;
reg [2:0]in;
wire [7:0]out;
integer i;
decoder3X8 dut(in,out);
initial
begin
for (i=0;i<8;i=i+1)
begin
in=i;
#10;
end
end
endmodule
2) 8 bit graycounter 
module graycounteightbit(clk,out,rst);
input clk,rst;
output reg [2:0] out;
reg [2:0]count;
always @(posedge clk)
begin
if (rst)
begin
count<=3'b000;
out<=3'b000;
end
else
begin
count<=count+1'b1;
out[2]<=count[2];
out[1]<=count[2]^count[1];
out[0]<=count[1]^count[0];
end
end
endmodule
module test;
reg clk,rst;
wire [2:0]out;
practice dut(clk,out,rst);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
end
always #5 clk=~clk;
endmodule
3) half adder using 4X1 mux
module mux4X1(in1,in2,in3,in4,sel1,sel2,out);
input in1,in2,in3,in4,sel1,sel2;
output reg out;
always @(*)
begin
if ({sel1,sel2}==2'b00)
out=in1;
else if ({sel1,sel2}==2'b01)
out=in2;
else if ({sel1,sel2}==2'b10)
out=in3;
else if ({sel1,sel2}==2'b11)
out=in4;
end
endmodule

module halfadderusingmux(x,y,sum,carry);
input x,y;
output sum,carry;
mux4X1 d1(0,1,1,0,x,y,sum);
mux4X1 d2(0,0,0,1,x,y,carry);
endmodule

module test;
reg x,y;
wire sum,carry;
practice dut(x,y,sum,carry);
initial
begin
x=1'b0;
y=1'b0;
#10
x=1'b0;
y=1'b1;
#10
x=1'b1;
y=1'b0;
#10
x=1'b1;
y=1'b1;
end
endmodule
4) 8 X 3 Priority Encoder
 module prioencder(in,out);
input [7:0]in;
output reg [2:0]out;
always @(*)
begin
casex(in)
8'b00000001 : out = 3'b000;
8'b0000001x : out = 3'b001;
8'b000001xx : out = 3'b010;
8'b00001xxx : out = 3'b011;
8'b0001xxxx : out = 3'b100;
8'b001xxxxx : out = 3'b101;
8'b01xxxxxx : out = 3'b110;
8'b1xxxxxxx : out = 3'b111;
default : out=3'bxxx;
endcase
end
endmodule
module test;
reg [7:0]in;
wire [2:0]out;
practice dut(in,out);
initial
begin
in=8'b11001100; #10;
in=8'b01100110; #10;
in=8'b00110011; #10;
in=8'b00010010; #10;
in=8'b00001001; #10;
in=8'b00000100; #10;
in=8'b00000011; #10;
in=8'b00000001; #10;
in=8'b00000000; # 10; 
end
endmodule
5) 8_bit_barrel_shifter

module mux2X1(in0,in1,out,sel);
input in0,in1,sel;
output out;
wire w1,w2,w3;
not(w1,sel);
and(w2,w1,in0);
and(w3,sel,in1);
or(out,w2,w3);
endmodule

module barrel8bitshifter(in,out,s);
input [7:0] in;
input [2:0] s;
output [7:0] out;
wire [15:0]w;
mux2X1 one(in[7],in[0],w[0],s[0]);
mux2X1 two(in[6],in[7],w[1],s[0]);
mux2X1 three(in[5],in[6],w[2],s[0]);
mux2X1 four(in[4],in[5],w[3],s[0]);
mux2X1 five(in[3],in[4],w[4],s[0]);
mux2X1 six(in[2],in[3],w[5],s[0]);
mux2X1 seven(in[1],in[2],w[6],s[0]);
mux2X1 eight(in[0],in[1],w[7],s[0]);

mux2X1 one1(w[0],w[6],w[8],s[1]);
mux2X1 two2(w[1],w[7],w[9],s[1]);
mux2X1 three3(w[2],w[0],w[10],s[1]);
mux2X1 four4(w[3],w[1],w[11],s[1]);
mux2X1 five5(w[4],w[2],w[12],s[1]);
mux2X1 six6(w[5],w[3],w[13],s[1]);
mux2X1 seven7(w[6],w[4],w[14],s[1]);
mux2X1 eight8(w[7],w[5],w[15],s[1]);

mux2X1 one11(w[8],w[12],out[7],s[2]);
mux2X1 two22(w[9],w[13],out[6],s[2]);
mux2X1 three33(w[10],w[14],out[5],s[2]);
mux2X1 four44(w[11],w[15],out[4],s[2]);
mux2X1 five55(w[12],w[8],out[3],s[2]);
mux2X1 six66(w[13],w[9],out[2],s[2]);
mux2X1 seven77(w[14],w[10],out[1],s[2]);
mux2X1 eight88(w[15],w[11],out[0],s[2]);


endmodule
module tb;
reg [7:0] in;
reg [2:0] s;
wire [7:0] out;
practice dut(in,out,s);
initial
begin
in=8'b00001111;
s=3'b000;
#10
in=8'b00001111;
s=3'b001;
#10
in=8'b00001111;
s=3'b010;
#10
in=8'b00001111;
s=3'b011;
#10
in=8'b00001111;
s=3'b100;
#10
in=8'b00001111;
s=3'b101;
#10
in=8'b00001111;
s=3'b110;
#10
in=8'b00001111;
s=3'b111;

end
endmodule
S0 S1 S2 input      output
0  0  0  00001111   00001111
0  0  1  00001111   10000111
0  1  0  00001111   11000011
0  1  1  00001111   11100001
1  0  0  00001111   11110000
1  0  1  00001111   01111000
1  1  0  00001111   00111100
1  1  1  00001111   00011110
6) 4*4 muliplier

module Halfadder(a,b,s,c);
input a,b;
output s,c;
xor(s,a,b);
and(c,a,b);
endmodule

module Fulladder(a,b,cin,sum,cout);
input a,b,cin;
output sum,cout;
wire w1,w2,w3;
Halfadder HA1(a,b,w1,w2);
Halfadder HA2(w1,cin,sum,w3);
or(cout,w2,w3);
endmodule

module multiplier4X4(a,b,out);
input [3:0] a,b;
output [7:0] out;
wire [32:0] w;
and(out[0],a[0],b[0]);
and(w[1],a[1],b[0]);
and(w[2],a[0],b[1]);
and(w[3],a[1],b[1]);
and(w[4],a[2],b[0]);
and(w[5],a[2],b[1]);
and(w[6],a[3],b[0]);
and(w[12],a[0],b[2]);
and(w[14],a[1],b[2]);
and(w[17],a[3],b[1]);
and(w[20],a[0],b[3]);
and(w[22],a[2],b[2]);
and(w[25],a[3],b[2]);
and(w[28],a[1],b[3]);
and(w[30],a[2],b[3]);
and(w[32],a[3],b[3]);
Halfadder HA3(w[1],w[2],out[1],w[7]);
Fulladder FA1(w[3],w[4],w[7],w[8] ,w[9]);
Fulladder FA2(w[5],w[6],w[9],w[10],w[11]);
Halfadder HA4(w[12],w[8],out[2],w[13]);
Fulladder FA3(w[14],w[10],w[13],w[15],w[16]);
Fulladder FA4(w[17],w[11],w[16],w[18],w[19]);
Halfadder HA5(w[20],w[15],out[3],w[21]);
Fulladder FA5(w[22],w[21],w[18],w[23],w[24]);
Fulladder FA6(w[25],w[24],w[19],w[26],w[27]);
Halfadder HA6(w[28],w[23],out[4],w[29]);
Fulladder FA7(w[30],w[29],w[26],out[5],w[31]);
Fulladder FA8(w[32],w[31],w[27],out[6],out[7]);
endmodule
module test;
reg [3:0] a,b;
wire [7:0] out;
practice dut(a,b,out);
initial
begin
a=4'b1000;
b=4'b1000;
#10
a=4'b1010;
b=4'b0011;
#10
a=4'b0001;
b=4'b0001;
#10
a=4'b0001;
b=4'b0000;
#10
a=4'b1101;
b=4'b0011;
#10
a=4'b1111;
b=4'b1111;
#10
a=4'b0000;
b=4'b0000;
#10
a=4'b1001;
b=4'b1001;

end
endmodule
7) 4 bit carry select adder

module Fulladder(a,b,cin,sum,cout);
input a,b,cin;
output sum,cout;
wire [2:0] w;
xor(w[0],a,b);
xor(sum,w[0],cin);
and(w[1],w[0],cin);
and(w[2],a,b);
or(cout,w[1],w[2]);
endmodule

module mux2X1(in1,in2,sel,out);
input in1,in2,sel;
output out;
wire [2:0]w;
not(w[0],sel);
and(w[1],in2,sel);
and(w[2],in1,w[0]);
or(out,w[1],w[2]);
endmodule
module carryselectadder(a,b,sum,cout);
input [3:0]a,b;
output cout;
output [3:0]sum;
wire [15:0] w;
Fulladder FA1(a[0],b[0],1'b0,w[0],w[1]);
Fulladder FA2(a[1],b[1],w[1],w[2],w[3]);
Fulladder FA3(a[2],b[2],w[3],w[4],w[5]);
Fulladder FA4(a[3],b[3],w[5],w[6],w[13]);

Fulladder FA5(a[0],b[0],1'b1,w[7],w[8]);
Fulladder FA6(a[1],b[1],w[8],w[9],w[10]);
Fulladder FA7(a[2],b[2],w[10],w[11],w[12]);
Fulladder FA8(a[3],b[3],w[12],w[14],w[15]);

mux2X1 MUX1(w[0],w[7],1'b0,sum[0]);
mux2X1 MUX2(w[2],w[9],1'b0,sum[1]);
mux2X1 MUX3(w[4],w[11],1'b0,sum[2]);
mux2X1 MUX4(w[6],w[14],1'b0,sum[3]);
mux2X1 MUX5(w[13],w[15],1'b0,cout);
endmodule

module tb;
reg [3:0]a,b;
wire cout;
wire [3:0] sum;
carryselectadder dut(a,b,sum,cout);
initial
begin
a=4'b1010;
b=4'b0001;
end
endmodule
8) 8X1 mux using 2:4 decoder

module decoder(in1,in2,q);
input in1,in2;
output reg [3:0]q;
always @(in1,in2)
begin
case({in1,in2})
2'b00 : q=4'b0001;
2'b01 : q=4'b0010;
2'b10 : q=4'b0100;
2'b11 : q=4'b1000;
endcase
end
endmodule

module mux(enable,in1,in2,sel,out);
input enable,in1,in2,sel;
output reg out;
always @(enable,in1,in2,sel)
begin
if (enable)
begin
if (sel==1'b0)
out=in1;
else
out=in2;
end
else
out=1'b0;
end
endmodule

module 8X1muxusingdecoder(in,sel,out);
input [7:0] in;
input [2:0] sel;
output out;
wire [3:0]w,o;
decoder d1(sel[2],sel[1],w);
mux m1(w[0],in[0],in[1],sel[0],o[0]);
mux m2(w[1],in[2],in[3],sel[0],o[1]);
mux m3(w[2],in[4],in[5],sel[0],o[2]);
mux m4(w[3],in[6],in[7],sel[0],o[3]);
or(out,o[0],o[1],o[2],o[3]);
endmodule
module tb;
reg [7:0] in;
reg [2:0] sel;
wire out;
practice dut(in,sel,out);
initial
begin
sel=3'b000;
in=8'b00000001;
#10
sel=3'b001;
in=8'b00101001;
#10
sel=3'b111;
in=8'b10000000;
#10
sel=3'b101;
in=8'b00100000;
end
endmodule
9) 1X8 demux using 1X4 demux and 1X2 demux

module demux1X2(in,sel,out);
input in,sel;
output reg [1:0]out;
always @(in,sel)
begin
if (sel==1'b0)
begin
out[0]=in;
out[1]=1'b0;
end
else
begin
out[1]=in;
out[0]=1'b0;
end
end
endmodule

module demux1X4(in,sel,out);
input in;
input [1:0] sel;
output reg [3:0] out;
always @(in,sel)
begin
if (sel==2'b00)
begin
out[0]=in;
out[1]=1'b0;
out[2]=1'b0;
out[3]=1'b0;
end
else if (sel==2'b01)
begin
out[0]=1'b0;
out[1]=in;
out[2]=1'b0;
out[3]=1'b0;
end
else if (sel==2'b10)
begin
out[0]=1'b0;
out[1]=1'b0;
out[2]=in;
out[3]=1'b0;
end
else
begin
out[0]=1'b0;
out[1]=1'b0;
out[2]=1'b0;
out[3]=in;
end
end
endmodule

module demux1X8(in,sel,out);
input in;
input [2:0]sel;
output [7:0]out;
wire [1:0]w;
demux1X2 d1(in,sel[2],w);
demux1X4 d2U(w[1],sel[1:0],out[7:4]);
demux1X4 d3L(w[0],sel[1:0],out[3:0]);
endmodule

module tb;
reg in;
reg [2:0] sel;
wire [7:0] out;
practice dut(in,sel,out);
initial
begin
in=1'b1;
sel=3'b000;
#5
in=1'b1;
sel=3'b001;
#5
in=1'b1;
sel=3'b010;
#5
in=1'b1;
sel=3'b011;
#5
in=1'b1;
sel=3'b100;
#5
in=1'b1;
sel=3'b101;
#5
in=1'b1;
sel=3'b110;
#5
in=1'b1;
sel=3'b111;
end
endmodule
10) 2X4 decoder and two mux and one xor gate
module decoder2X4(a,b,out);
input a,b;
output reg [3:0] out;
always @(a,b)
begin
case({a,b})
2'b00 : out=4'b0001;
2'b01 : out=4'b0010;
2'b10 : out=4'b0100;
2'b11 : out=4'b1000;
endcase
end
endmodule
module mux2X1(a,b,sel,out);
input a,b,sel;
output reg out;
always @(a,b,sel)
begin
if (sel==1'b0)
out=a;
else
out=b;
end
endmodule


module somerandomcircuit(a,b,c,d,out);
input a,b,c,d;
output out;
wire [3:0]w;
wire w1,w2;
decoder2X4 d1(a,b,w);
mux2X1 U(w[3],w[2],c,w1);
mux2X1 D(w[1],w[0],d,w2);
xor(out,w1,w2);
endmodule

module tb;
reg a,b,c,d;
reg check;
wire out;
practice dut(a,b,c,d,out);
initial
begin
a=1'b0;
b=1'b0;
c=1'b0;
d=1'b0;
#0.5
if ( out==(((a)&(~b)&(~d))|((a)&(b)&(d))|((a)&(~b)&(~c))|((~a)&(b)&(c))))
check=1'b1;
else
check=1'b0;
end

endmodule
11) 4 bit SISO shift register
module SISO4bit(in,clk,out);
input in,clk;
output reg out;
reg [2:0]q;
always @(posedge clk)
begin
q[2]<=in;
q[1]<=q[2];
q[0]<=q[1];
out<=q[0];
end

endmodule
module tb;
reg in,clk;
wire out;
practice dut(in,clk,out);
initial
begin
clk=1'b0;
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
end
always #5 clk=~clk;
endmodule

12) 4 bit SIPO shift register

module SIPO4bit(in,clk,out3,out2,out1,out0);
input in,clk;
output reg out3,out2,out1,out0;
always @(posedge clk)
begin
out3<=in;
out2<=out3;
out1<=out2;
out0<=out1;

end
endmodule
module tb;
reg clk,in;
wire out3,out2,out1,out0;
practice dut(in,clk,out3,out2,out1,out0);
initial
begin
clk=1'b0;
in=0;
#40
in=1'b1;
#10
in=1'b1;
#10;
in=1'b0;
#10
in=1'b1;
#10
$stop();
end
always #5 clk=!clk;
endmodule
13) 4 bit PISO shift register
 module piso(in,clk,reset,out);
input [3:0]in;
input clk,reset;
output reg out;
reg [2:0] q;
always @(posedge clk)
begin
if (reset)
begin
q[2]<=in[3];
q[1]<=in[2];
q[0]<=in[1];
out<=in[0];
end
else
begin
q[2]<=1'bx;
q[1]<=q[2];
q[0]<=q[1];
out<=q[0];
end
end
endmodule
module tb;
reg [3:0] in;
reg clk,reset;
wire out;
practice dut(in,clk,reset,out);
initial
begin
clk=1'b0;
reset=1'b1;
in=4'b1001;
#6
reset=1'b0;
end
always #5 clk=~clk;
endmodule

14) 4 bit PIPO shift register

module practice(clk,rst,in,out);
input clk,rst;
input [3:0] in;
output reg [3:0] out;
always @(posedge clk)
begin
if(rst)
begin
out[3]<=in[3];
out[2]<=in[2];
out[1]<=in[1];
out[0]<=in[0];
end
else
begin
out[3]<=1'b0;
out[2]<=out[3];
out[1]<=out[2];
out[0]<=out[1];
end
end
endmodule

module tb;
reg clk,rst;
reg [3:0] in;
wire [3:0] out;
practice dut(clk,rst,in,out);
initial
begin
clk=1'b0;
rst=1'b1;
in=4'b1101;
#6
rst=1'b0;
end
always #5 clk=~clk;
endmodule
15) 4 bit asynchronous Simultaneous “Up” and “Down” Counter
module jkf(j,k,clk,out,outbar,rst);
input j,k,clk,rst;
output reg out,outbar;
wire w1,w2,w3,w4;
always @(negedge clk)
begin
if(rst==1'b1)
begin
out<=1'b0;
outbar<=1'b1;
end
else if(j==1'b0 && k==1'b1)
begin
out<=1'b0;
outbar<=1'b1;
end
else if(j==1'b1 && k==1'b0)
begin
out<=1'b1;
outbar<=1'b0;
end
else if(j==1'b1 && k==1'b1)
begin
out<=~out;
outbar<=~outbar;
end
else
begin
out<=out;
outbar<=outbar;
end

end
endmodule


module asyncountre(clk,rst,outup,outdown);
input clk,rst;
output [3:0] outup,outdown;
jkf d1(1'b1,1'b1,clk,outup[0],outdown[0],rst);
jkf d2(1'b1,1'b1,outdown[0],outup[1],outdown[1],rst);
jkf d3(1'b1,1'b1,outdown[1],outup[2],outdown[2],rst);
jkf d4(1'b1,1'b1,outdown[2],outup[3],outdown[3],rst);

endmodule

module tb;
reg clk,rst;
wire [3:0] outup,outdown;
practice dut(clk,rst,outup,outdown);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
end
always #5 clk=~clk;
endmodule

16) MOD 10 Asynchronous counter 
The below code work fine on simulator(eda playground but not in quartus prime)

module asycounter10(clk,out,rst);
input clk,rst;
output reg [3:0] out;
wire w;
always @(negedge clk or posedge w)
begin
if(rst==1'b1 || w==1'b1 )
out[0]<=1'b0;
else
out[0]<=~out[0];
end
always @(negedge out[0] or posedge w)
begin
if(rst==1'b1 || w==1'b1)
out[1]<=1'b0;
else
out[1]<=~out[1];
end
always @(negedge out[1] or posedge w )
begin
if(rst==1'b1 || w==1'b1)
out[2]<=1'b0;
else
out[2]<=~out[2];
end
always @(negedge out[2] or posedge w )
begin
if(rst==1'b1 || w==1'b1)
out[3]<=1'b0;
else
out[3]<=~out[3];
end
assign  #1 w=out[3]&out[1];//provide delay for correct operation
endmodule

module tb;
reg clk,rst;
wire [3:0] out;
asycounter10 dut(clk,out,rst);
initial
begin
clk=1'b0;
rst=1'b0;
#11
rst=1'b1;
#22
rst=1'b0;
end
always #5 clk=~clk;
endmodule

17) Dual Edge Triggered Flip Flop

module DDFF(in,out,clk,rst);
input in,clk,rst;
output reg out;
reg q1,q2;
always @(posedge clk)
begin
if (rst)
q1<=0;
else
q1<=in;
end
always @(negedge clk)
begin
if (rst)
q2<=0;
else
q2<=in;
end
always @(q1,q2,clk)
begin
if (clk==1'b1)
out=q1;
else
out=q2;
end
endmodule

module tb;
reg in,clk,rst;
wire out;
DDFF dut(in,out,clk,rst);
initial
begin
clk=1'b0;
rst=1'b1;
in=1'b1;
#11
rst=1'b0;
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
end
always #5 clk=~clk;
endmodule

18) Design synchronous counter for the 3-7-0-6-4-1 sequence using D Flip Flop

module syncounter(clk,rst,q);
input clk,rst;
output reg [3:1] q;
always @(posedge clk)
begin
if(rst)
q<=3'b011;
else
begin
q[3]<=((~q[3])&q[2])|(q[2]&(~q[1]))|((~q[3])&(~q[1]));
q[2]<=~q[3];
q[1]<=((~q[3])&q[1])|(q[3]&(~q[2]));
end
end
endmodule
module tb;
reg clk,rst;
wire [3:1] q;
syncounter dut(clk,rst,q);
initial
begin
clk=1'b0;
rst=1'b1;
#7
rst=1'b0;
end
always # 5 clk=~clk;
endmodule

19) 4bit johnson counter

module DFF(clk,rst,in,out,outbar);
input clk,rst,in;
output reg out,outbar;
always @(posedge clk)
begin
if(rst)
begin
out<=1'b0;
outbar<=1'b1;
end
else
begin
out<=in;
outbar<=~in;
end
end
endmodule
module johncounter(clk,rst,out,outbar);
input clk,rst;
output [3:0] out,outbar;
DFF d3(clk,rst,outbar[0],out[3],outbar[3]);
DFF d2(clk,rst,out[3],out[2],outbar[2]);
DFF d1(clk,rst,out[2],out[1],outbar[1]);
DFF d0(clk,rst,out[1],out[0],outbar[0]);
endmodule

module tb;
reg clk,rst;
wire [3:0] out,outbar;
johncounter dut(clk,rst,out,outbar);
initial
begin
clk=1'b0;
rst=1'b1;
#7
rst=1'b0;
end
always #5 clk=~clk;
endmodule

20) 4 bit LFSR circuit
(https://inst.eecs.berkeley.edu/~cs150/sp03/handouts/15/LectureA/lec27-2up.pdf in this website page 1 you can refe
diagram and output)

module LFSR(clk,rst,q);
input clk,rst;
output reg [3:0] q;
always @(posedge clk)
begin
if(rst)
begin
q[3]<=1'b0;
q[2]<=1'b0;
q[1]<=1'b0;
q[0]<=1'b1;
end
else
begin
q[0]<=q[3];
q[1]<=q[3]^q[0];
q[2]<=q[1];
q[3]<=q[2];
end
end
endmodule

module tb;
reg clk,rst;
wire [3:0] q;
practice LFSR(clk,rst,q);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
end
always # 5 clk=~clk;
endmodule

21) 11011 FSM overlapping Morre machine
 module fsm(clk,rst,in,out);
input clk,rst,in;
output reg out;
parameter A=3'b000,B=3'b001,C=3'b010,D=3'b100,E=3'b111,F=3'b110;
reg [2:0] ps,ns;
always @(posedge clk)
begin
if(rst)
ps<=A;
else
ps<=ns;
end
always @(ps,in)
begin
case(ps)
A : begin
ns=in?B:A;
out=1'b0;
end
B : begin
ns=in?C:A;
out=1'b0;
end
C : begin
ns=in?C:D;
out=1'b0;
end
D : begin
ns=in?E:A;
out=1'b0;
end
E : begin
ns=in?F:A;
out=1'b0;
end
F : begin
ns=in?C:D;
out=1'b1;
end
endcase
end
endmodule

module tb;
reg clk,rst,in;
wire out;
fsm dut(clk,rst,in,out);
initial
begin
clk=1'b0;
rst=1'b1;
in=1'b1;
#6
rst=1'b0;
#19
in=1'b1;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b1;
#10;
in=1'b0;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10;
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b1;
end
always #5 clk=~clk;
endmodule

22) 101010  overlapping FSM mealy machine 

module mealy(clk,rst,in,out);
input clk,rst,in;
output reg out;
parameter A=4'b0000,B=4'b0001,C=4'b0010,D=4'b0100,E=4'b1000,F=4'b1100;
reg [3:0] ps,ns;
always @(posedge clk)
begin
if(rst)
ps<=A;
else
ps<=ns;
end

always @(ps,in)
begin
case(ps)
A: begin
ns=in?B:A;
out=1'b0;
end
B: begin
ns=in?B:C;
out=1'b0;
end
C: begin
ns=in?D:A;
out=1'b0;
end
D: begin
ns=in?B:E;
out=1'b0;
end
E: begin
ns=in?F:A;
out=1'b0;
end
F: begin
ns=in?B:E;
out=in?1'b0:1'b1;
end
endcase
end
endmodule

module tb;
reg clk,rst,in;
wire out;
mealy dut(clk,rst,in,out);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
#9
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
end
always #5 clk=~clk;
endmodule

23) 1001 & 010 overlapping mealy FSM

module mealy(clk,rst,in,out);
input clk,rst,in;
output reg out;
parameter S0=4'b0000,S1=4'b0001,S2=4'b0010,S3=4'b0100,S4=4'b1000,S5=4'b1100;
reg [3:0] ns,ps;
always @(posedge clk)
begin
if(rst)
ps<=S0;
else
ps<=ns;
end

always @(ps,in)
begin
case(ps)
S0: begin
ns=in?S1:S4;
out=1'b0;
end
S1: begin
ns=in?S1:S2;
out=1'b0;
end
S2: begin
ns=in?S5:S3;
out=1'b0;
end
S3: begin
ns=in?S5:S4;
out=in?1'b1:1'b0;
end
S4: begin
ns=in?S5:S4;
out=1'b0;
end
S5: begin
ns=in?S1:S2;
out=in?1'b0:1'b1;
end
endcase
end
endmodule

module tb;
reg clk,rst,in;
wire out;
mealy dut(clk,rst,in,out);
initial
begin
clk=1'b0;
rst=1'b1;
in=1'b1;
#6
rst=1'b0;
#9
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
end
always #5 clk=~clk;
endmodule

24) 2's complement of a binary number using Moore FSM

module (clk,rst,in,out);
input clk,rst,in;
output reg out;
parameter A=2'b00,B=2'b01,C=2'b10;
reg [1:0] ps,ns;
always @(posedge clk)
begin
if(rst)
ps<=A;
else
ps<=ns;
end

always @(ps,in)
begin
case(ps)
A : begin
ns=in?B:A;
out=1'b0;
end
B : begin
ns=in?C:B;
out=1'b1;
end
C : begin
ns=in?C:B;
out=1'b0;
end
endcase
end
endmodule

module tb;
reg clk,rst,in;
wire out;
complement dut(clk,rst,in,out);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
#9
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
end
always #5 clk=~clk;
endmodule

25) Vending machine using mealy machine with change
In this, we will get drink bottle when price = 15 , and we have only 5 and 10 avialable

module machine(clk,rst,coin,bottlereceived,change);
input clk,rst;
input [3:0] coin;
output reg bottlereceived;
output reg [3:0] change;
parameter S0=2'b00,S1=2'b01,S2=2'b10;
reg [1:0] ps,ns;

always @(posedge clk)
begin
if(rst)
ps<=S0;
else
ps<=ns;
end

always @(ps,coin)
begin
case(ps)
S0 : begin
ns = (coin==4'b0101) ? S1 : ((coin==4'b1010) ? S2:S0);
bottlereceived = 1'b0;
change = 4'b0000;
end
S1 : begin
ns = (coin==4'b0101) ? S2 : S0;
bottlereceived = (coin==4'b1010) ? 1'b1 : 1'b0;
change = (coin==4'b0000) ? 4'b0101 : 4'b0000;
end
S2 : begin
ns = S0;
bottlereceived = (coin==4'b0101 || coin==4'b1010) ? 1'b1 : 1'b0;
change = (coin==4'b1010)? 4'b0101 : ((coin==4'b0000) ? 4'b1010 : 4'b0000);
end
endcase
end
endmodule

module tb;
reg clk,rst;
reg [3:0] coin;
wire bottlereceived;
wire [3:0] change;
machine dut(clk,rst,coin,bottlereceived,change);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
#9
coin=4'b0101;
#10;
coin=4'b0101;
#10;
coin=4'b0101;
#10;
coin=4'b0101;
#10;
coin=4'b1010;
#10;
coin=4'b1010;
#10;
coin=4'b0101;
#10;
coin=4'b1010;
#10;
coin=4'b1010;
#10;
coin=4'b1010;
#10;
coin=4'b0000;
end
always #5 clk=~clk;
endmodule

26) single port SRAM with Synchronous read/write

module sram(clk,datain,dataout,enablewrite,readaddress,writeaddress);
input clk,enablewrite;
input [7:0] datain;
input [5:0] readaddress,writeaddress;
output reg [7:0] dataout;
reg [7:0] ram [63:0];

always @(posedge clk)
begin
if(enablewrite)
ram[writeaddress]<=datain;
dataout<=ram[readaddress];
end
endmodule

module tb;
reg clk,enablewrite;
reg [5:0] readaddress,writeaddress;
reg [7:0] datain;
wire [7:0] dataout;
sram dut(clk,datain,dataout,enablewrite,readaddress,writeaddress);
initial
begin
clk=1'b0;
enablewrite=1'b0;
datain=8'b00000000;
#12
enablewrite=1'b1;
datain=8'b11110000;
writeaddress=6'b000000;
readaddress=6'b000000;
#10
datain=8'b11111111;
writeaddress=6'b000000;
readaddress=6'b000000;

end
initial
begin
#30
$finish();
end
always #5 clk=~clk;
endmodule

27) Synchronous FIFO

module fifo(clk,rst,wen,ren,data,dataout,full,empty);
input clk,rst,wen,ren;
input [7:0] data;
output reg [7:0] dataout;
output full,empty;
reg [7:0] memory [15:0];
reg [3:0] wrptr,rdptr;
integer i;
always @(posedge clk)
begin
if (rst)
begin
for(i=0;i<16;i=i+1)
memory[i]=8'b00000000;
wrptr<=4'b0000;
dataout<=8'b00000000;
rdptr<=4'b0000;
end
// write
else if (wen==1'b1)
begin
if (wrptr <  4'b1111)
begin
memory[wrptr]<=data;
wrptr<=wrptr+1'b1;
end
else if(wrptr==4'b1111)
begin
memory[wrptr]<=data;
end
end

//read
else if(ren==1'b1)
begin
if(rdptr!=wrptr)
begin
dataout<=memory[rdptr];
memory[rdptr]<=8'b00000000;
rdptr<=rdptr+1'b1;
end
else if(rdptr==wrptr)
begin
dataout<=memory[rdptr];
memory[rdptr]<=8'b00000000;
wrptr<=4'b0000;
rdptr<=4'b0000;
end
end
end
assign empty=(rdptr==wrptr)?1'b1:1'b0;
assign full=(wrptr==4'b1111)?1'b1:1'b0;
endmodule

module tb;
reg clk,rst,wen,ren;
reg [7:0] data;
wire [7:0] dataout;
wire full,empty;
fifo dut(clk,rst,wen,ren,data,dataout,full,empty);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
wen=1'b1;
#9
data=8'b01010101;
#10;
data=8'b10101010;
#10;
data=8'b00001111;
#10;
data=8'b11110000;
#10;
data=8'b00110011;
#10;
data=8'b11001100;
#10;
data=8'b11100011;
#10;
data=8'b00011100;
#5;
wen=1'b0;
#5
ren=1'b1;
end
always #5 clk=~clk;
endmodule

28) Generate output = 1 for 4 clock cycle and for next 4 clock cycle output = 0. Repeat this sequence for forever

module clk4(clk,rst,out);
input clk,rst;
output reg out;
reg [3:0] pose,nege;
always @(posedge clk)
begin
if (rst)
begin
pose=4'b0000;
nege=4'b0000;
out=1'b0;
end
else
begin
if((pose<4'b0100) && ((nege==4'b0000) || (nege>=4'b0100)))
begin
out=1'b1;
pose=pose+1'b1;
nege=4'b0000;
end
else if (pose >= 4'b0100)
begin
out=1'b0;
nege=nege+1'b1;
pose=4'b0000;
end
else if (nege < 4'b0100)
begin
out=1'b0;
nege=nege+1'b1;
pose=4'b0000;
end
end
end
endmodule

module tb;
reg clk,rst;
wire out;
clk4 dut(clk,rst,out);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
end
always # 5 clk=~clk;
endmodule

29) Moore FSM gives output 1 when detects even number of ones recived else output is 0

module even(clk,rst,in,out);
input clk,rst,in;
output reg out;
parameter S0=3'b100,S1=3'b010,S2=3'b001;
reg [2:0] ps,ns;
always @(posedge clk)
begin
if(rst)
ps<=S0;
else
ps<=ns;
end

always @(ps,in)
begin
case(ps)
S0 : begin
ns=in?S1:S0;
out=1'b0;
end
S1 : begin
ns=in?S2:S1;
out=1'b0;
end
S2 : begin
ns=in?S1:S0;
out=1'b1;
end
endcase
end
endmodule

module tb;
reg clk,rst,in;
wire out;
even dut(clk,rst,in,out);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
#9
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b1;
end
always #5 clk=~clk;
endmodule

30) Design a synchronous Traffic light controller cicuit

module trafficlight(clk,rst,red,green,yellow);
input clk,rst;
output  red,green,yellow;
parameter GREEN = 3'b000 ,YELLOW = 3'b001 ,RED = 3'b010 ,REDYELLOW = 3'b100 ,WAITED = 3'b111;
reg [2:0] ps,ns;
reg [5:0] count;

always @(posedge clk)
begin
if(rst)
ps <= GREEN;
else
ps <= ns;
end

always @(ps,count)
begin
case(ps)
GREEN : ns = (count == 6'b001111) ? YELLOW : GREEN;
YELLOW : ns = (count == 6'b010100) ? RED : YELLOW;
RED : ns = (count == 6'b011110) ? REDYELLOW : RED;
REDYELLOW : ns = (count == 6'b100011) ? WAITED : REDYELLOW;
WAITED : ns = GREEN;
endcase
end

always @(posedge clk)
begin
if(rst)
count <= 5'b000000;
else if (ps == WAITED)
count <= 5'b000000;
else
count <= count + 1'b1;
end

assign red = (ps == RED || ps == REDYELLOW) ? 1'b1 : 1'b0;
assign yellow = (ps == YELLOW || ps == REDYELLOW) ? 1'b1 : 1'b0;
assign green = (ps == GREEN) ? 1'b1 : 1'b0;
endmodule

module tb;
reg clk,rst;
wire red,green,yellow;
trafficlight dut(clk,rst,red,green,yellow);

initial
begin
clk = 1'b0;
rst = 1'b1;
#6
rst = 1'b0;

end
always #5 clk = ~clk;
endmodule

31) Lfsr5 ( https://hdlbits.01xz.net/wiki/Lfsr5)
module lfsr5(clk,reset,q);
    input clk,reset;
    output reg [4:0] q;
    always @(posedge clk)
        begin
            if(reset)
                q <= 5'h1;
            else
                begin
                    q[4] <= 1'b0^q[0];
                    q[3] <= q[4];
                    q[2] <= q[0]^q[3];
                    q[1] <= q[2];
                    q[0] <= q[1];
                end
        end
endmodule

32) A 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and
   carry out. (https://hdlbits.01xz.net/wiki/Adder100)

 module Fulladder(in1,in2,carryin,sum,carryout);
    input in1,in2,carryin;
    output sum,carryout;
    assign sum = in1^in2^carryin;
    assign carryout = in2&carryin | (in1)&(in2|carryin);
endmodule


module adder100(a,b,cin,cout,sum);
    input [99:0] a,b;
    input cin;
    output cout;
    output [99:0] sum;
    wire [98:0] w;
    Fulladder f1(a[0],b[0],cin,sum[0],w[0]);
    genvar i;
    generate
        begin
            for( i = 1; i<=98 ; i=i+1)
                begin : adder
                    Fulladder f2(a[i],b[i],w[i-1],sum[i],w[i]);
                end
        end
    endgenerate
    Fulladder f3(a[99],b[99],w[98],sum[99],cout);
endmodule

33) module that outputs a 32 bit number. Write verilog code to grab bits 8-14 bits.

module Grabbits(in,out);

input [31:0] in;

output reg [7:0] out;

reg [31:0] temp;

integer i;

always @(in)

begin

temp = in >> 8;

for( i = 0; i <= 7; i = i+1)
begin

out[i] = temp[0] & 1'b1;

temp = temp >> 1;

end
end

endmodule

module tb;

reg [31:0] in;

wire [7:0] out;

Grabbits dut(in,out);

initial

begin
in = 32'b00000000000000000101010100000000;
end
endmodule

34) Finite state machine (FSM) for an automatic reversible 6 modulo counter as follows: 
    The counter counts 0, 1, 2, 3, 4, 5 (when  input is  0) and reverses: 5 4, 3, 2, 1, 0 
    (when input is 1)

module count0to5(clk,rst,in,out);

input clk,rst,in;
output reg [3:0] out;
parameter A = 4'b0000, B = 4'b0001, C = 4'b0010, D = 4'b0011, E = 4'b0100, F = 4'b0101,  G = 4'b0111, H = 4'b1000,I = 4'b1001, J = 4'b1010, K = 4'b1011, L = 4'b1100;
reg [3:0] ps, ns;

always @(posedge clk)
begin
if(rst)
ps <= A;
else
ps <= ns;
end

always @(ps,in)
begin
case (ps)
A : begin
ns = B;
out = 4'b0000;
end

B : begin
ns = C;
out = 4'b0001;
end

C : begin
ns = D;
out = 4'b0010;
end

D : begin
ns = E;
out = 4'b0011;
end

E : begin
ns = F;
out = 4'b0100;
end

F : begin
ns = in ? G : A;
out = 4'b0101;
end

G : begin
ns = H;
out = 4'b0101;
end

H : begin
ns = I;
out = 4'b0100;
end

I : begin
ns = J;
out = 4'b0011;
end

J : begin
ns = K;
out = 4'b0010;
end

K : begin
ns = L;
out = 4'b0001;
end

L : begin
ns = in ? A : G; 
out = 4'b0000;
end
endcase
end
endmodule

module tb;

reg clk,rst,in;
wire[3:0] out;

count0to5 dut(clk,rst,in,out);

initial
begin
clk = 1'b0;
rst = 1'b1;
in = 1'b1;
#10;
rst = 1'b0;
#60;
in = 1'b0;
end

always # 5 clk = ~clk;

endmodule

35) Simple and basic UART transmitter which transfer 8 bit data frame

module uarttx(clk,rst,data_in,done,data_out,stop_bit,start_bit);

input clk,rst,data_in;
output done,data_out,stop_bit,start_bit;

parameter idle = 3'b000, start = 3'b001, transfer = 3'b010, endd = 3'b100;
reg [2:0] ps,ns;
reg [3:0] count;

always @(posedge clk)
begin
if(rst)
ps <= idle;
else
ps <= ns;
end


always @(ps,data_in,count)
begin
case(ps)
idle : ns = start;
start : ns = data_in ? start : transfer;
transfer : ns = (count == 4'b1000) ? (data_in ? endd : start) : transfer;
endd : ns = data_in ? start : transfer;
endcase
end

always @(posedge clk)
begin
if(rst)
count <= 4'b0000;
else if(ps == transfer)
count <= count + 1'b1;
else
count <= 4'b0000;
end

assign done = (ps == endd) ? 1'b1 : 1'b0;
assign data_out = (ps == transfer) ? data_in : 1'bx;
assign start_bit = (ps == start) ? 1'b1 : 1'b0;
assign stop_bit = (count == 4'b1000) ? data_in : 1'b0; 
endmodule

module tb;
reg clk,rst,data_in;
wire done,data_out,stop_bit,start_bit;
uarttx dut(clk,rst,data_in,done,data_out,stop_bit,start_bit);

initial
begin
clk = 1'b0;
rst = 1'b1;
data_in = 1'b1;
#6
rst = 1'b0;
#19
data_in = 1'b0;
#10
data_in = 1'b1;
#10;
data_in = 1'b1;
#10;
data_in = 1'b1;
#10;
data_in = 1'b1;
#10;
data_in = 1'b1;
#10;
data_in = 1'b1;
#10;
data_in = 1'b1;
#10;
data_in = 1'b0;
#10;
data_in = 1'b1;
#40;
data_in = 1'b0;
#10
data_in = 1'b1;
#10;
data_in = 1'b0;
#10;
data_in = 1'b1;
#10;
data_in = 1'b0;
#10;
data_in = 1'b1;
#10;
data_in = 1'b0;
#10;
data_in = 1'b1;
#10;
data_in = 1'b0;
#10;
data_in = 1'b1;

end

always #5 clk = ~clk;
endmodule

36) Solution to HDLbits problem (https://hdlbits.01xz.net/wiki/Exams/review2015_fsmseq)

module top_module(clk ,reset ,data ,start_shifting);
    input clk,reset,data;
    output start_shifting;
    parameter S0 = 4'b0000 ,S1 = 4'b0001 ,S2 = 4'b0010 ,S3 = 4'b0100 ,S4 = 4'b1000;
    reg [3:0] ps ,ns;
    
    always @(posedge clk)
        begin
            if(reset)
                ps <= S0;
            else
                ps <= ns;
        end
    
    always @(ps,data)
        begin
            case(ps)
                S0 : ns = data ? S1 : S0;
                S1 : ns = data ? S2 : S0;
                S2 : ns = data ? S2 : S3;
                S3 : ns = data ? S4 : S0;
                S4 : ns = S4;
            endcase
        end
    
    assign start_shifting = (ps == S4) ? 1'b1 : 1'b0;
    
endmodule

37) Solution to HDLBITS Exams/2013 q2afsm (https://hdlbits.01xz.net/wiki/Exams/2013_q2afsm)

module top_module (clk ,resetn ,r ,g);
    input clk,resetn;
    input [3:1] r;
    output [3:1] g;
    
    parameter A = 3'b000 ,B = 3'b001 ,C = 3'b010 ,D = 3'b100;
    reg [2:0] ps,ns;
    
    always@(posedge clk)
        if(~resetn)
            ps <= A;
     else
            ps <= ns;
    
    always@(ps ,r)
        case(ps)
            A : ns = r[1] ? B : (r[2] ? C : (r[3] ? D : A));
            B : ns = r[1] ? B :A;
            C : ns = r[2] ? C :A;
            D : ns = r[3] ? D :A;
        endcase
    
    assign g[1] = (ps == B) ? 1'b1 : 1'b0;
    assign g[2] = (ps == C) ? 1'b1 : 1'b0;
    assign g[3] = (ps == D) ? 1'b1 : 1'b0;
    
endmodule

//  Lemmings series 

38) HDLbits solution of Lemmings1(https://hdlbits.01xz.net/wiki/Lemmings1)

module top_module(clk ,areset ,bump_left ,bump_right ,walk_left ,walk_right);
    
    input clk ,areset ,bump_left ,bump_right;
    output walk_left ,walk_right;
    
    parameter Left = 2'b00 , Right = 2'b01;
    reg [1:0] ps ,ns;
    
    always @(posedge clk or posedge areset)
        begin
            if(areset)
                ps <= Left;
            else
                ps <= ns;
        end
    
    always @(ps ,bump_left ,bump_right)
        begin
            case(ps)
                Left  : ns = bump_left  ? Right : Left;
                Right : ns = bump_right ? Left  : Right;
            endcase
        end
    
    assign walk_left  = (ps == Left)  ? 1'b1 : 1'b0;
    assign walk_right = (ps == Right) ? 1'b1 : 1'b0;
    
endmodule

39) HDLbits solution of Lemmings2(https://hdlbits.01xz.net/wiki/Lemmings2)

module top_module(clk ,areset ,bump_left ,bump_right ,ground ,walk_left ,walk_right ,aaah);
    
    input clk ,areset ,bump_left ,bump_right ,ground;
    output walk_left ,walk_right ,aaah;
    
    parameter LEFT  = 3'b000 ,RIGHT = 3'b001 ,FALL_L = 3'b010 ,FALL_R = 3'b100;
    reg [2:0] ps ,ns;
    
    always @(posedge clk or posedge areset)
        begin
            if(areset)
                ps <= LEFT;
            else
                ps <= ns;
        end
    
    always @(ps ,bump_left ,bump_right ,ground)
        begin
            case(ps)
                LEFT   : ns = ~ground ? FALL_L : (bump_left  ? RIGHT :  LEFT);
                RIGHT  : ns = ~ground ? FALL_R : (bump_right ? LEFT  : RIGHT);
                FALL_L : ns = ~ground ? FALL_L :  LEFT;
                FALL_R : ns = ~ground ? FALL_R : RIGHT;
            endcase
        end
    
    assign walk_left  = (ps ==  LEFT) ? 1'b1 : 1'b0;
    assign walk_right = (ps == RIGHT) ? 1'b1 : 1'b0;
    assign aaah = (ps == FALL_L || ps == FALL_R) ? 1'b1 : 1'b0;
    
endmodule

40) HDLbits solution of Lemmings3(https://hdlbits.01xz.net/wiki/Lemmings3)

module top_module(clk ,areset ,bump_left ,bump_right ,ground , dig, walk_left ,walk_right ,aaah ,digging);
    
    input clk ,areset ,bump_left ,bump_right ,ground , dig;
    output walk_left ,walk_right ,aaah ,digging;
    
    parameter WalkL = 4'b0000 ,WalkR = 4'b1000 ,FallL = 4'b0100 ,FallR = 4'b0010 ,DigL = 4'b0001 ,DigR = 4'b1111;
    reg [3:0] ps ,ns;
    
    always @(posedge clk or posedge areset)
        begin
            if(areset)
                ps <= WalkL;
            else
                ps <= ns;
        end
    
    always @(ps ,bump_left ,bump_right ,ground , dig)
        begin
            case(ps)
                WalkL : ns = !ground ? FallL : (dig ? DigL : (bump_left  ? WalkR : WalkL));
                WalkR : ns = !ground ? FallR : (dig ? DigR : (bump_right ? WalkL : WalkR));
                FallL : ns = !ground ? FallL : WalkL;
                FallR : ns = !ground ? FallR : WalkR;
                DigL  : ns = !ground ? FallL : DigL;
                DigR  : ns = !ground ? FallR : DigR;
            endcase
        end
    
    assign walk_left  = (ps == WalkL) ? 1'b1 : 1'b0;
    assign walk_right = (ps == WalkR) ? 1'b1 : 1'b0;
    assign aaah    = (ps == FallL || ps == FallR) ? 1'b1 : 1'b0;
    assign digging = (ps == DigL  || ps == DigR)  ? 1'b1 : 1'b0;
    
endmodule

41) HDLbits solution of Exams/2014 q3fsm(https://hdlbits.01xz.net/wiki/Exams/2014_q3fsm)

module top_module(clk ,reset ,s ,w ,z);
    
    input clk ,reset ,s ,w;
    output reg z;
    
    parameter A = 1'b1 ,B = 1'b0;
    reg ps ,ns;
    reg [1:0] countclk ,countone;
    
    always @(posedge clk)
        begin
            if(reset)
                ps <= A;
            else
                ps <= ns;
        end
    
    always @(ps ,s)
        case(ps)
            A : ns = s ? B : A;
            B : ns = B;
        endcase
    
    always @(posedge clk)
        begin
            if(reset)
                begin
                    countclk <= 2'b00;
                    countone <= 2'b00;
                    z        <= 1'b0;
                end
            else
                begin
                    if(ps == B)
                        begin
                            countclk <= countclk + 1'b1;
                            if(countclk == 2'b10)
                                begin
                                    countclk <= 1'b0;
                                    if(w == 1)
                                        begin
                                            countone <= countone + 1'b1;
                                            if(countone == 2'b10 && w != 1'b1)
                                                begin
                                                    z <= 1'b1;
                                                    countone <= 1'b0;
                                                end
                                            else
                                                begin
                                                    if(countone == 1'b1 && w == 1'b1)
                                                        begin
                                                            z <= 1'b1;
                                                            countone <= 1'b0;
                                                        end
                                                    else
                                                        begin
                                                            z <= 1'b0;
                                                            countone <= 1'b0;
                                                        end
                                                end
                                        end
                                    else
                                        begin
                                            if(countone == 2'b10)
                                                begin
                                                    z <= 1;
                                                    countone <= 1'b0;
                                                end
                                            else
                                                begin
                                                    z <= 1'b0;
                                                    countone <= 1'b0;
                                                end
                                        end
                                end
                            else
                                begin
                                    z <= 1'b0;
                                    if(w == 1'b1)
                                        countone <= countone + 1'b1;
                                    else
                                        countone <= countone;
                                end
                        end
                    else
                        z <= 1'b0;
                    
                end
        end
    
endmodule

42) 4bit wallace multiplier 

module HalfAdder(a ,b ,sum ,carry);

input a ,b;
output sum ,carry;

xor(sum ,a ,b);
and(carry ,a ,b);

endmodule

module FullAdder(a ,b ,c ,sum ,carry);

input a ,b ,c;
output sum ,carry;

wire [2:0] nets;

xor(sum ,a ,b ,c);
and(nets[0] ,a ,b);
and(nets[1] ,a ,c);
and(nets[2] ,b ,c);
or(carry ,nets[0] ,nets[1] ,nets[2]);

endmodule

module Wallacemultiplier(A ,B ,Out);

input [3:0] A ,B;
output [7:0] Out;

wire [15:1] nets;
wire [5:0] sum;
wire [10:0] carry;

and(Out[0] ,A[0] ,B[0]);
and(nets[1] ,A[0] ,B[1]);
and(nets[2] ,A[1] ,B[0]);
and(nets[3] ,A[2] ,B[0]);
and(nets[4] ,A[0] ,B[2]);
and(nets[5] ,A[1] ,B[1]);
and(nets[6] ,A[2] ,B[1]);
and(nets[7] ,A[3] ,B[0]);
and(nets[8] ,A[0] ,B[3]);
and(nets[9] ,A[1] ,B[2]);
and(nets[10] ,A[3] ,B[1]);
and(nets[11] ,A[1] ,B[3]);
and(nets[12] ,A[2] ,B[2]);
and(nets[13] ,A[2] ,B[3]);
and(nets[14] ,A[3] ,B[2]);
and(nets[15] ,A[3] ,B[3]);

HalfAdder HA1(nets[8] ,nets[9] ,sum[0] ,carry[0]);
HalfAdder HA2(nets[11] ,nets[12] ,sum[1] ,carry[1]);

FullAdder FA1(nets[4] ,nets[5] ,1'b0 ,sum[2] ,carry[2]);
FullAdder FA2(nets[6] ,nets[7] ,sum[0] ,sum[3] ,carry[3]);
FullAdder FA3(nets[10] ,carry[0] ,sum[1] ,sum[4] ,carry[4]);
FullAdder FA4(nets[13] ,nets[14] ,carry[1] ,sum[5] ,carry[5]);

HalfAdder HA3(nets[1] ,nets[2] ,Out[1] ,carry[6]);
FullAdder FA5(nets[3] ,carry[6] ,sum[2] ,Out[2] ,carry[7]);
FullAdder FA6(carry[2] ,carry[7] ,sum[3] ,Out[3] ,carry[8]);
FullAdder FA7(carry[3] ,carry[8] ,sum[4] ,Out[4] ,carry[9]);
FullAdder FA8(carry[4] ,carry[9] ,sum[5] ,Out[5] ,carry[10]);
FullAdder FA9(carry[5] ,carry[10] ,nets[15] ,Out[6] ,Out[7]);

endmodule


module tb;

reg [3:0] A ,B;
wire [7:0] Out;

Wallacemultiplier dut(A ,B ,Out);

initial
begin
A = 4'b0011;
B = 4'b1100;
#10;
A = 4'b1010;
B = 4'b1110;
#10;
A = 4'b1111;
B = 4'b1111;
#10;
A = 4'b0000;
B = 4'b0000;
end

endmodule

43) Design an FSM- finite state machine to check whether the two inputs A and B have the same value for the
previous three samples. Use Mealy machine for the design.

module checksequence(clk ,rst ,inputsequence1 ,inputsequence2 ,out);

input clk ,rst ,inputsequence1 ,inputsequence2;
output  out;

parameter A = 3'b000 ,B = 3'b001 ,C = 3'b100;
reg [2:0] ps ,ns;

always @(posedge clk)
begin
if(rst)
ps <= A;
else
ps <= ns;
end


always @(ps ,inputsequence1 ,inputsequence2)
begin
case(ps)
A : ns  = (inputsequence1 == inputsequence2) ? B : A;
B : ns  = (inputsequence1 == inputsequence2) ? C : A;
C : ns  = (inputsequence1 == inputsequence2) ? C : A;
endcase
end

assign out = ((inputsequence1 == inputsequence2) && (ps == C)) ? 1'b1 : 1'b0;

endmodule

module tb;

reg clk ,rst ,inputsequence1 ,inputsequence2;
wire out;

checksequence dut(clk ,rst ,inputsequence1 ,inputsequence2 ,out);

always #5 clk = ~clk;

initial
begin
clk = 1'b0;
rst = 1'b1;
#6;
rst = 1'b0;
#9;
inputsequence1 = 1'b0;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b0;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b0;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b1;
inputsequence2 = 1'b1;
#10;
inputsequence1 = 1'b0;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b1;
inputsequence2 = 1'b1;
#10;
inputsequence1 = 1'b0;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b0;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b1;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b0;
inputsequence2 = 1'b1;
#10;
inputsequence1 = 1'b1;
inputsequence2 = 1'b0;
#40
inputsequence1 = 1'b0;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b0;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b0;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b1;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b0;
inputsequence2 = 1'b1;
#10;
inputsequence1 = 1'b0;
inputsequence2 = 1'b1;
#10;
inputsequence1 = 1'b1;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b1;
inputsequence2 = 1'b1;
#10;
inputsequence1 = 1'b1;
inputsequence2 = 1'b1;
#10;
inputsequence1 = 1'b0;
inputsequence2 = 1'b1;
#10;
inputsequence1 = 1'b0;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b0;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b1;
inputsequence2 = 1'b1;

end

endmodule

44) Design a finite state machine for a serial binary input which is divisible by 5

module fsm5(clk ,rst ,in ,out);

input clk ,rst ,in;
output out;

parameter A = 5'b00001 ,R1 = 5'b00010 ,R2 = 5'b00100 ,R3 = 5'b01000 ,R4 = 5'b10000 ,R0 = 5'b00000;
reg [4:0] ps ,ns;

always @(posedge clk)
begin
if(rst)
ps <= A;
else
ps <= ns;
end

always @(ps ,in)
begin
case(ps)
A  : ns = in ? R1 : A;
R1 : ns = in ? R3 : R2;
R2 : ns = in ? R0 : R4;
R3 : ns = in ? R2 : R1;
R4 : ns = in ? R4 : R3;
R0 : ns = in ? R1 : R0;
endcase
end

assign out = (ps == R0) ? 1'b1 : 1'b0;

endmodule

module tb;

reg clk ,rst ,in;
wire out;

fsm5 dut(clk ,rst ,in ,out);

initial
begin
clk = 1'b0;
rst = 1'b1;
in = 1'b1;
#6
rst = 1'b0;
#9
in = 1'b1;
#10
in = 1'b1;
#10
in = 1'b0;
#10
in = 1'b0;
#10
in = 1'b0;
#10
in = 1'b0;
#10
in = 1'b1;
#10
in = 1'b0;
#10
in = 1'b0;
#10
in = 1'b1;
#10
in = 1'b1;
#40
in = 1'b1;
#10
in = 1'b0;
#10
in = 1'b1;
#10
in = 1'b1;
#10
in = 1'b0;
#10
in = 1'b1;
#10
in = 1'b0;

#40
in = 1'b1;
#10
in = 1'b0;
#10
in = 1'b0;
#10
in = 1'b0;
#10
in = 1'b1;
#10
in = 1'b0;
#10
in = 1'b0;
#10
in = 1'b1;
#10
in = 1'b0;
#10
in = 1'b0;
#10
in = 1'b1;
#10
in = 1'b1;

#40
in = 1'b1;
#10
in = 1'b1;
#10
in = 1'b0;
#10
in = 1'b1;
#10
in = 1'b1;
#10
in = 1'b1;
#10
in = 1'b0;
#10
in = 1'b1;
#10
in = 1'b1;
#10
in = 1'b1;
#10
in = 1'b1;
#40
in = 1'b1;
#10;
in = 1'b1;
#10;
in = 1'b1;
#10;
in = 1'b0;
#10;
in = 1'b0;
#10;
in = 1'b0;
#10;
in = 1'b0;
#10;
in = 1'b0;
#10;
in = 1'b0;
#10;
in = 1'b0;
#10;
in = 1'b1;
end

always #5 clk = ~clk;

endmodule

45) Design a finite state machine for a serial binary input which is divisible by 4

module fsm4(clk ,rst ,in ,out);

input clk ,rst ,in;
output out;

parameter idle = 4'b0000 ,remone = 4'b0001 ,remtwo = 4'b0010 ,remthree = 4'b0100 ,remzero = 4'b1000;
reg [3:0] ps ,ns;

always @(posedge clk)
begin
if(rst)
ps <= idle;
else
ps <= ns;
end

always @(ps ,in)
begin
case(ps)
idle     : ns = in ? remone   : idle;
remone   : ns = in ? remthree : remtwo;
remtwo   : ns = in ? remone   : remzero;
remthree : ns = in ? remthree : remtwo;
remzero  : ns = in ? remone   : remzero;
endcase
end

assign out = (ps == remzero) ? 1'b1 : 1'b0;

endmodule

module tb;

reg clk ,rst ,in;
wire out;

fsm4 dut(clk ,rst ,in ,out);

always #5 clk = ~clk;

initial
begin
clk = 1'b0;
rst = 1'b1;
#6
rst = 1'b0;
#9;
in = 0;
#20;
in = 1'b1;
#10;
in = 1'b1;
#10;
in = 1'b1;
#10;
in = 1'b0;
#20;
in = 1'b1;
#10;
in = 1'b1;
#10;
in = 1'b0;
#10;
in = 1'b1;
#10;
in = 1'b1;
#10;
in = 1'b1;
#20;
in = 1'b1;
#10 ;
in = 1'b0;
#10 ;
in = 1'b0;
#10 ;
in = 1'b1;
end

endmodule

46) CLOCK TIMER(24 HOUR SYSTEM)

module clock(clk ,rst ,hr ,mm ,ss);

input clk ,rst;
output reg [7:0] hr ,mm ,ss;

integer hour ,min ,sec;

always @(posedge clk)
begin
if(rst)
begin
hr   <= 8'b0000_0000;
mm   <= 8'b0000_0000;
ss   <= 8'b0000_0000;
hour <= 0;
min  <= 0;
sec  <= 0;
end
else
begin
sec <= sec + 1;
ss  <= sec;
if(ss == 59)
begin
sec <= 0;
ss  <= 8'b0000_0000;
min <= min + 1;
mm  <= min + 1;
if(mm == 59)
begin
min  <= 0;
mm   <= 8'b0000_0000;
hour <= hour + 1;
hr   <= hour + 1;
if(hr == 23)
begin
hour <= 0;
hr   <= 8'b0000_0000;
end
end
end
end
end

endmodule

module tb;

reg clk ,rst;
wire [7:0] hr ,mm ,ss;

clock dut(clk ,rst ,hr ,mm ,ss);

always #5 clk = ~clk;

initial
begin
clk = 1'b0;
rst = 1'b1;
#6
rst = 1'b0;
end

endmodule

47) LIFO BUFFER

module lifo(clk ,rst ,en ,rw ,datain ,dataout ,empty ,full);

input  clk ,rst ,en ,rw;
input  [7:0] datain;
output empty ,full;
output reg [7:0] dataout;

reg [7:0] lifobuffer[15:0];
reg [4:0] skptr;

integer i;

always @(posedge clk)
begin
if(rst)
begin
for(i = 0 ;i<=15 ;i = i + 1)
lifobuffer[i] = 8'b0000_0000;
skptr         = 5'b00000;
end
else if(!full & en & !rw)
begin
lifobuffer[skptr] = datain;
skptr             = skptr + 1'b1;
end
else if(!empty & en & rw)
begin
skptr             = skptr - 1'b1;
dataout           = lifobuffer[skptr];
lifobuffer[skptr] = 8'b0000_0000;
end
end

assign full  = (skptr == 5'b10000) ? 1'b1 : 1'b0;
assign empty = (skptr == 5'b00000) ? 1'b1 : 1'b0;

endmodule


module tb;

reg  clk ,rst ,en ,rw;
reg  [7:0] datain;
wire empty ,full;
wire [7:0] dataout;

lifo dut(clk ,rst ,en ,rw ,datain ,dataout ,empty ,full);


always #5 clk = ~clk;

initial
begin
clk = 1'b0;
rst = 1'b1;
#6
rst = 1'b0;
en  = 1'b1;
#9;
rw     = 1'b0;
datain = 8'b1000_0001;
#10;
datain = 8'b1000_0010;
#10;
datain = 8'b1000_0011;
#10;
datain = 8'b1000_0111;
#10;
datain = 8'b1000_1111;
#10;
datain = 8'b1001_1111;
#10;
datain = 8'b1011_1111;
#10;
datain = 8'b1111_1111;
#10;
datain = 8'b1111_1000;
#10;
datain = 8'b1111_0000;
#10;
datain = 8'b1010_1010;
#10;
datain = 8'b0000_1111;
#10;
datain = 8'b1111_1111;
#10;
datain = 8'b1000_0001;
#10;
datain = 8'b0000_1111;
#10;
datain = 8'b1001_1001;
#10;
rw = 1'b1;
end

endmodule

48) HDLBITS(https://hdlbits.01xz.net/wiki/Exams/m2014_q6)

module top_module(clk ,reset ,w ,z);
    
    input clk ,reset ,w;
    output  z;
    
    parameter A = 5'b00000 ,B = 5'b00001 ,C = 5'b00010 ,D = 5'b00100 ,E = 5'b01000 ,F = 5'b10000;
    reg [4:0] ps ,ns;
    
    always @(posedge clk)
        begin
            if(reset)
                ps <= A;
            else
                ps <= ns;
        end
    
    always @(ps ,w)
        begin
            case(ps)
                A : ns = w ? A : B;
                B : ns = w ? D : C;
                C : ns = w ? D : E;
                D : ns = w ? A : F;
                E : ns = w ? D : E;
                F : ns = w ? D : C;
            endcase
        end
    
    assign z = ( ps == E || ps == F ) ? 1'b1 : 1'b0;
    
endmodule

49) ALU DESIGN 

module aludesign(A ,B ,operation ,result);

input [3:0] A ,B ,operation;
output reg [7:0] result;

always @(A or B  or operation)
begin
case(operation)
4'b0000 : result = A + B;    //Addition
4'b0001 : result = A - B;    //Substraction
4'b0010 : result = A / B;    //Divison
4'b0011 : result = A * B;    //Multiplication
4'b0101 : result = A & B;    //and operation
4'b0110 : result = A | B;    //or operation
4'b0111 : result = A ^ B;    //xor operation
4'b1000 : result = ~(A ^ B); //xnor operation
4'b1001 : result = ~(A & B); //nand operation
4'b1010 : result = ~(A | B); //nor operation
4'b1011 : result = (A > B) ? 1'b1 : 1'b0; // if A > B -> 1
4'b1100 : result = (B > A) ? 1'b1 : 1'b0; // if B > A -> 1
4'b1101 : result = {A ,B};   //concatenation operation
default : result = A + B;    //Addition
endcase
end

endmodule

module tb;

reg [3:0] A ,B ,operation;
wire [7:0] result;

aludesign dut(A ,B ,operation ,result);

initial
begin
A = 4'b1111;
B = 4'b1111;
operation = 4'b0000;
#10;
A = 4'b1111;
B = 4'b1111;
operation = 4'b0001;
#10;
A = 4'b1111;
B = 4'b1111;
operation = 4'b0010;
#10;
A = 4'b1111;
B = 4'b1111;
operation = 4'b0101;
#10;
A = 4'b1111;
B = 4'b1111;
operation = 4'b1101;
#10;
A = 4'b1101;
B = 4'b1111;
operation = 4'b1011;
#10;
A = 4'b1110;
B = 4'b1111;
operation = 4'b1100;
end

endmodule

50) 4 Bit Controlled Buffer Register

module flipflop(clk ,rst ,in ,out);

input clk ,rst ,in;
output reg out;

always @(posedge clk)
begin
if(~rst) // reset is active low
out <= 1'b0;
else
out <= in;
end

endmodule

module combcircuit(in1 ,in2 ,in3 ,out1);//in3 output of FF and in2 is the main input and in1 is load

input in1 ,in2 ,in3;
output out1;
wire w1 ,w2 ,w3;

and a1(w1 ,in1 ,in2);
not n1(w3 ,in1);
and a2(w2 ,w3 ,in3);
or  o1(out1 ,w1 ,w2);

endmodule

module buffercontroller(clk ,clr ,load ,datain ,dataout);

input clk ,clr ,load;
input  [3:0] datain;
output [3:0] dataout;

wire [3:0] w;

combcircuit c1(load ,datain[0] ,dataout[0]  ,w[0]);
flipflop    f1(clk  ,clr   ,w[0]      ,dataout[0]);
combcircuit c2(load ,datain[1] ,dataout[1]  ,w[1]);
flipflop    f2(clk  ,clr   ,w[1]      ,dataout[1]);
combcircuit c3(load ,datain[2] ,dataout[2]  ,w[2]);
flipflop    f3(clk  ,clr   ,w[2]      ,dataout[2]);
combcircuit c4(load ,datain[3] ,dataout[3]  ,w[3]);
flipflop    f4(clk  ,clr   ,w[3]      ,dataout[3]);

endmodule

module tb;

reg  clk ,clr ,load;
reg  [3:0] datain;
wire [3:0] dataout;

buffercontroller dut(clk ,clr ,load ,datain ,dataout);

always #5 clk = ~clk;

initial
begin
clk    = 1'b0;
clr    = 1'b0;
load   = 1'b1;
#6
clr    = 1'b1;
#9;
datain = 4'b1111;
#10;
load   = 1'b0;
datain = 4'b1010;
#20
load   = 1'b1;
datain = 4'b1010;

end

endmodule

51) HDLBITS(https://hdlbits.01xz.net/wiki/Exams/2014_q3bfsm)

module top_module(clk ,reset ,x ,z);
    
    input clk ,reset ,x;
    output  z;
    
    parameter S0 = 4'b000 ,S1 = 4'b001 ,S2 = 4'b010 ,S3 = 4'b011 ,S4 = 4'b100;
    reg [2:0] ps ,ns;
    
    always @(posedge clk)
        begin
            if(reset)
                ps <= S0;
            else
                ps <= ns;
            
        end
    
    always @(ps ,x)
        case(ps)
            S0 : ns = x ? S1 : S0;
            S1 : ns = x ? S4 : S1;
            S2 : ns = x ? S1 : S2;
            S3 : ns = x ? S2 : S1;
            S4 : ns = x ? S4 : S3;
        endcase
    
    assign z = (ps == S3 || ps == S4) ? 1'b1 : 1'b0;
    
endmodule

52) Frequency Divider by 5 

module counter(clk ,rst ,out);

input clk ,rst;
output reg [2:0] out;

always @(posedge clk)
begin
if(rst)
out <= 3'b000;
else if(out == 3'b100)
out <= 3'b000;
else
out <= out + 1'b1;
end

endmodule

module flipflop(clk ,rst ,in ,out);

input clk ,rst ,in;
output reg out;

always @(negedge clk)
begin
if(rst)
out <= 1'b0;
else
out <= in;
end

endmodule

module divider(clk ,rst ,out);

input clk ,rst;
output out;

wire [2:0] w;
wire w1;
counter  c1(clk ,rst ,w);
flipflop f1(clk ,rst ,w[1] ,w1);
or(out ,w[1] ,w1);

endmodule


module tb;

reg clk ,rst;
wire out;

divider dut(clk ,rst ,out);

always #5 clk = ~clk;

initial
begin
clk = 1'b0;
rst = 1'b1;
#11;
rst = 1'b0;
end

endmodule

53) Frequency Divider by 6

module FF(clk ,rst ,in ,out ,outbar);

input clk ,rst ,in;
output reg out ,outbar;

always @(posedge clk)
begin
if(rst)
begin
out    <= 1'b0;
outbar <= 1'b1;
end
else
begin
out    <= in;
outbar <= ~in;
end
end

endmodule

module frequencydividebysix(clk ,rst ,out);

input clk ,rst;
output out;

wire [2:0] outbar;
wire [1:0] out_put;

FF F1(clk ,rst ,outbar[2]  ,out_put[0] ,outbar[0]);
FF F2(clk ,rst ,out_put[0] ,out_put[1] ,outbar[1]);
FF F3(clk ,rst ,out_put[1] ,out        ,outbar[2]);

endmodule

module tb;

reg clk ,rst;
wire out;

frequencydividebysix dut(clk ,rst ,out);

always #5 clk = ~clk;

initial
begin
clk = 1'b0;
rst = 1'b1;
#6;
rst = 1'b0;
end

endmodule

54) fibonacci series

module fibonacci(clk ,rst ,out);

input clk ,rst;
output reg [7:0] out;
reg [7:0] help;

always @(posedge clk)
begin
if(rst)
begin
out  <= 8'b0000_0000;
help <= 8'b0000_0001;
end
else
begin
out  <= out + help;
help <= out;
end
end

endmodule

module tb;

reg clk ,rst;
wire [7:0] out;

fibonacci dut(clk ,rst ,out);

always #5 clk = ~clk;

initial
begin
clk = 1'b0;
rst = 1'b1;
#6;
rst = 1'b0;
end

initial
begin
#80;
$finish();
end
endmodule

55) Factorial of a number

module fact(clk ,rst ,number ,factorialofnumber);

input  clk ,rst;
input  [3:0] number;
output reg [31:0] factorialofnumber;

parameter idle = 3'b0001 ,checker = 3'b010 ,operation = 3'b100 ,result = 3'b000;
reg [2:0]  ps ,ns;
reg [31:0]  num ,tempnum ,capture;
reg [31:0] count;
reg [31:0] sum;


always @(posedge clk)
begin
if(rst)
ps <= idle;
else
ps <= ns;
end

always @(ps ,num ,count ,number)
begin
case(ps)
idle      : ns = (number == 0 || number == 1) ? result : checker;
checker   : ns = (num == 4'b0001) ? result : operation;
operation : ns = (count == 1) ? checker : operation;
result    : ns = result;
endcase
end

always @(posedge clk)
begin
if(rst)
begin
num               <= number - 1;
tempnum           <= number;
count             <= 32'b00000000000000000000000000000000;
sum               <= 32'b00000000000000000000000000000000;
capture           <= 32'b00000000000000000000000000000000;
end
else if(ps == checker)
begin
count             <= num;
capture           <= tempnum;
factorialofnumber <= sum;
sum               <= 32'b00000000000000000000000000000000;
end
else if(ps == operation)
begin
if(count != 0)
begin
sum   <= sum + tempnum;
count <= count - 1;
if(count == 1)
begin
tempnum <= sum + capture;
num     <= num - 1;
end
end
end
else if(ps == result)
begin
if(number == 0 || number == 1)
factorialofnumber <= 1;
end
end

endmodule

module tb;

reg  clk ,rst;
reg  [3:0] number;
wire [31:0] factorialofnumber;

fact dut(clk ,rst ,number ,factorialofnumber);

always #5 clk = ~clk;

initial
begin
clk = 1'b0;
rst = 1'b1;
number = 4'b0111;
#6
rst = 1'b0;
end

endmodule

56) Write code for following pattern
    0000_0001 ,0001_0000 ,0000_0001 ,0010_0000 ,0000_0001 ,0100_0000 ,0000_0001 ,1000_0000 and repeat

module pattern(clk ,rst ,out);

input clk ,rst;
output reg [7:0] out;
reg [3:0] temp;
reg check;

always @(posedge clk)
begin
if(rst)
begin
out   <= 8'b0000_0001;
temp  <= 4'b0100;
check <= 1'b1;
end
else
begin
out   <= check & 1'b1 ? (out[7] ? 8'b0000_0001 : out << temp) : (out[7] ? 8'b0000_0001 : out >> temp);
temp  <= check & 1'b1 ? temp : ((temp[2] & temp[1] & temp[0]) ? 4'b0100:temp + 1'b1);
check <= ~check;
end
end

endmodule

module tb;

reg clk ,rst;
wire [7:0] out;

pattern dut(clk ,rst ,out);

always # 5 clk = ~clk;

initial
begin
clk = 1'b0;
rst = 1'b1;
#6;
rst = 1'b0;
end

endmodule
































    

    

    

			 




















































