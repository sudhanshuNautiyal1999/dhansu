1) 3 to 8 decoder
   module practice(in,out);
input [2:0] in;
output [7:0] out;
reg [7:0]out;
always @(*)
begin
case (in)
3'b000: out=8'b00000001;
3'b001: out=8'b00000010;
3'b010: out=8'b00000100;
3'b011: out=8'b00001000;
3'b100: out=8'b00010000;
3'b101: out=8'b00100000;
3'b110: out=8'b01000000;
3'b111: out=8'b10000000;
default : out=8'b00000000;

endcase

end

endmodule
module test;
reg [2:0]in;
wire [7:0]out;
integer i;
practice dut(in,out);
initial
begin
for (i=0;i<8;i=i+1)
begin
in=i;
#10;
end
end
endmodule
2) 8 bit graycounter 
module graycounteightbit(clk,out,rst);
input clk,rst;
output reg [2:0] out;
reg [2:0]count;
always @(posedge clk)
begin
if (rst)
begin
count<=3'b000;
out<=3'b000;
end
else
begin
count<=count+1'b1;
out[2]<=count[2];
out[1]<=count[2]^count[1];
out[0]<=count[1]^count[0];
end
end
endmodule
module test;
reg clk,rst;
wire [2:0]out;
practice dut(clk,out,rst);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
end
always #5 clk=~clk;
endmodule
3) half adder using 4X1 mux
module mux4X1(in1,in2,in3,in4,sel1,sel2,out);
input in1,in2,in3,in4,sel1,sel2;
output reg out;
always @(*)
begin
if ({sel1,sel2}==2'b00)
out=in1;
else if ({sel1,sel2}==2'b01)
out=in2;
else if ({sel1,sel2}==2'b10)
out=in3;
else if ({sel1,sel2}==2'b11)
out=in4;
end
endmodule

module halfadderusingmux(x,y,sum,carry);
input x,y;
output sum,carry;
mux4X1 d1(0,1,1,0,x,y,sum);
mux4X1 d2(0,0,0,1,x,y,carry);
endmodule

module test;
reg x,y;
wire sum,carry;
practice dut(x,y,sum,carry);
initial
begin
x=1'b0;
y=1'b0;
#10
x=1'b0;
y=1'b1;
#10
x=1'b1;
y=1'b0;
#10
x=1'b1;
y=1'b1;
end
endmodule
4) 8 X 3 Priority Encoder
 module prioencder(in,out);
input [7:0]in;
output reg [2:0]out;
always @(*)
begin
casex(in)
8'b00000001 : out = 3'b000;
8'b0000001x : out = 3'b001;
8'b000001xx : out = 3'b010;
8'b00001xxx : out = 3'b011;
8'b0001xxxx : out = 3'b100;
8'b001xxxxx : out = 3'b101;
8'b01xxxxxx : out = 3'b110;
8'b1xxxxxxx : out = 3'b111;
default : out=3'bxxx;
endcase
end
endmodule
module test;
reg [7:0]in;
wire [2:0]out;
practice dut(in,out);
initial
begin
in=8'b11001100; #10;
in=8'b01100110; #10;
in=8'b00110011; #10;
in=8'b00010010; #10;
in=8'b00001001; #10;
in=8'b00000100; #10;
in=8'b00000011; #10;
in=8'b00000001; #10;
in=8'b00000000; # 10; 
end
endmodule
5) 8_bit_barrel_shifter

module mux2X1(in0,in1,out,sel);
input in0,in1,sel;
output out;
wire w1,w2,w3;
not(w1,sel);
and(w2,w1,in0);
and(w3,sel,in1);
or(out,w2,w3);
endmodule

module barrel8bitshifter(in,out,s);
input [7:0] in;
input [2:0] s;
output [7:0] out;
wire [15:0]w;
mux2X1 one(in[7],in[0],w[0],s[0]);
mux2X1 two(in[6],in[7],w[1],s[0]);
mux2X1 three(in[5],in[6],w[2],s[0]);
mux2X1 four(in[4],in[5],w[3],s[0]);
mux2X1 five(in[3],in[4],w[4],s[0]);
mux2X1 six(in[2],in[3],w[5],s[0]);
mux2X1 seven(in[1],in[2],w[6],s[0]);
mux2X1 eight(in[0],in[1],w[7],s[0]);

mux2X1 one1(w[0],w[6],w[8],s[1]);
mux2X1 two2(w[1],w[7],w[9],s[1]);
mux2X1 three3(w[2],w[0],w[10],s[1]);
mux2X1 four4(w[3],w[1],w[11],s[1]);
mux2X1 five5(w[4],w[2],w[12],s[1]);
mux2X1 six6(w[5],w[3],w[13],s[1]);
mux2X1 seven7(w[6],w[4],w[14],s[1]);
mux2X1 eight8(w[7],w[5],w[15],s[1]);

mux2X1 one11(w[8],w[12],out[7],s[2]);
mux2X1 two22(w[9],w[13],out[6],s[2]);
mux2X1 three33(w[10],w[14],out[5],s[2]);
mux2X1 four44(w[11],w[15],out[4],s[2]);
mux2X1 five55(w[12],w[8],out[3],s[2]);
mux2X1 six66(w[13],w[9],out[2],s[2]);
mux2X1 seven77(w[14],w[10],out[1],s[2]);
mux2X1 eight88(w[15],w[11],out[0],s[2]);


endmodule
module tb;
reg [7:0] in;
reg [2:0] s;
wire [7:0] out;
practice dut(in,out,s);
initial
begin
in=8'b00001111;
s=3'b000;
#10
in=8'b00001111;
s=3'b001;
#10
in=8'b00001111;
s=3'b010;
#10
in=8'b00001111;
s=3'b011;
#10
in=8'b00001111;
s=3'b100;
#10
in=8'b00001111;
s=3'b101;
#10
in=8'b00001111;
s=3'b110;
#10
in=8'b00001111;
s=3'b111;

end
endmodule
S0 S1 S2 input      output
0  0  0  00001111   00001111
0  0  1  00001111   10000111
0  1  0  00001111   11000011
0  1  1  00001111   11100001
1  0  0  00001111   11110000
1  0  1  00001111   01111000
1  1  0  00001111   00111100
1  1  1  00001111   00011110
6) 4*4 muliplier

module Halfadder(a,b,s,c);
input a,b;
output s,c;
xor(s,a,b);
and(c,a,b);
endmodule

module Fulladder(a,b,cin,sum,cout);
input a,b,cin;
output sum,cout;
wire w1,w2,w3;
Halfadder HA1(a,b,w1,w2);
Halfadder HA2(w1,cin,sum,w3);
or(cout,w2,w3);
endmodule

module multiplier4X4(a,b,out);
input [3:0] a,b;
output [7:0] out;
wire [32:0] w;
and(out[0],a[0],b[0]);
and(w[1],a[1],b[0]);
and(w[2],a[0],b[1]);
and(w[3],a[1],b[1]);
and(w[4],a[2],b[0]);
and(w[5],a[2],b[1]);
and(w[6],a[3],b[0]);
and(w[12],a[0],b[2]);
and(w[14],a[1],b[2]);
and(w[17],a[3],b[1]);
and(w[20],a[0],b[3]);
and(w[22],a[2],b[2]);
and(w[25],a[3],b[2]);
and(w[28],a[1],b[3]);
and(w[30],a[2],b[3]);
and(w[32],a[3],b[3]);
Halfadder HA3(w[1],w[2],out[1],w[7]);
Fulladder FA1(w[3],w[4],w[7],w[8] ,w[9]);
Fulladder FA2(w[5],w[6],w[9],w[10],w[11]);
Halfadder HA4(w[12],w[8],out[2],w[13]);
Fulladder FA3(w[14],w[10],w[13],w[15],w[16]);
Fulladder FA4(w[17],w[11],w[16],w[18],w[19]);
Halfadder HA5(w[20],w[15],out[3],w[21]);
Fulladder FA5(w[22],w[21],w[18],w[23],w[24]);
Fulladder FA6(w[25],w[24],w[19],w[26],w[27]);
Halfadder HA6(w[28],w[23],out[4],w[29]);
Fulladder FA7(w[30],w[29],w[26],out[5],w[31]);
Fulladder FA8(w[32],w[31],w[27],out[6],out[7]);
endmodule
module test;
reg [3:0] a,b;
wire [7:0] out;
practice dut(a,b,out);
initial
begin
a=4'b1000;
b=4'b1000;
#10
a=4'b1010;
b=4'b0011;
#10
a=4'b0001;
b=4'b0001;
#10
a=4'b0001;
b=4'b0000;
#10
a=4'b1101;
b=4'b0011;
#10
a=4'b1111;
b=4'b1111;
#10
a=4'b0000;
b=4'b0000;
#10
a=4'b1001;
b=4'b1001;

end
endmodule
7) 4 bit carry select adder

module Fulladder(a,b,cin,sum,cout);
input a,b,cin;
output sum,cout;
wire [2:0] w;
xor(w[0],a,b);
xor(sum,w[0],cin);
and(w[1],w[0],cin);
and(w[2],a,b);
or(cout,w[1],w[2]);
endmodule

module mux2X1(in1,in2,sel,out);
input in1,in2,sel;
output out;
wire [2:0]w;
not(w[0],sel);
and(w[1],in2,sel);
and(w[2],in1,w[0]);
or(out,w[1],w[2]);
endmodule
module carryselectadder(a,b,sum,cout);
input [3:0]a,b;
output cout;
output [3:0]sum;
wire [15:0] w;
Fulladder FA1(a[0],b[0],1'b0,w[0],w[1]);
Fulladder FA2(a[1],b[1],w[1],w[2],w[3]);
Fulladder FA3(a[2],b[2],w[3],w[4],w[5]);
Fulladder FA4(a[3],b[3],w[5],w[6],w[13]);

Fulladder FA5(a[0],b[0],1'b1,w[7],w[8]);
Fulladder FA6(a[1],b[1],w[8],w[9],w[10]);
Fulladder FA7(a[2],b[2],w[10],w[11],w[12]);
Fulladder FA8(a[3],b[3],w[12],w[14],w[15]);

mux2X1 MUX1(w[0],w[7],1'b0,sum[0]);
mux2X1 MUX2(w[2],w[9],1'b0,sum[1]);
mux2X1 MUX3(w[4],w[11],1'b0,sum[2]);
mux2X1 MUX4(w[6],w[14],1'b0,sum[3]);
mux2X1 MUX5(w[13],w[15],1'b0,cout);
endmodule

module tb;
reg [3:0]a,b;
wire cout;
wire [3:0] sum;
practice dut(a,b,sum,cout);
initial
begin
a=4'b1010;
b=4'b0001;
end
endmodule
8) 8X1 mux using 2:4 decoder

module decoder(in1,in2,q);
input in1,in2;
output reg [3:0]q;
always @(in1,in2)
begin
case({in1,in2})
2'b00 : q=4'b0001;
2'b01 : q=4'b0010;
2'b10 : q=4'b0100;
2'b11 : q=4'b1000;
endcase
end
endmodule

module mux(enable,in1,in2,sel,out);
input enable,in1,in2,sel;
output reg out;
always @(enable,in1,in2,sel)
begin
if (enable)
begin
if (sel==1'b0)
out=in1;
else
out=in2;
end
else
out=1'b0;
end
endmodule

module 8X1muxusingdecoder(in,sel,out);
input [7:0] in;
input [2:0] sel;
output out;
wire [3:0]w,o;
decoder d1(sel[2],sel[1],w);
mux m1(w[0],in[0],in[1],sel[0],o[0]);
mux m2(w[1],in[2],in[3],sel[0],o[1]);
mux m3(w[2],in[4],in[5],sel[0],o[2]);
mux m4(w[3],in[6],in[7],sel[0],o[3]);
or(out,o[0],o[1],o[2],o[3]);
endmodule
module tb;
reg [7:0] in;
reg [2:0] sel;
wire out;
practice dut(in,sel,out);
initial
begin
sel=3'b000;
in=8'b00000001;
#10
sel=3'b001;
in=8'b00101001;
#10
sel=3'b111;
in=8'b10000000;
#10
sel=3'b101;
in=8'b00100000;
end
endmodule
9) 1X8 demux using 1X4 demux and 1X2 demux

module demux1X2(in,sel,out);
input in,sel;
output reg [1:0]out;
always @(in,sel)
begin
if (sel==1'b0)
begin
out[0]=in;
out[1]=1'b0;
end
else
begin
out[1]=in;
out[0]=1'b0;
end
end
endmodule

module demux1X4(in,sel,out);
input in;
input [1:0] sel;
output reg [3:0] out;
always @(in,sel)
begin
if (sel==2'b00)
begin
out[0]=in;
out[1]=1'b0;
out[2]=1'b0;
out[3]=1'b0;
end
else if (sel==2'b01)
begin
out[0]=1'b0;
out[1]=in;
out[2]=1'b0;
out[3]=1'b0;
end
else if (sel==2'b10)
begin
out[0]=1'b0;
out[1]=1'b0;
out[2]=in;
out[3]=1'b0;
end
else
begin
out[0]=1'b0;
out[1]=1'b0;
out[2]=1'b0;
out[3]=in;
end
end
endmodule

module demux1X8(in,sel,out);
input in;
input [2:0]sel;
output [7:0]out;
wire [1:0]w;
demux1X2 d1(in,sel[2],w);
demux1X4 d2U(w[1],sel[1:0],out[7:4]);
demux1X4 d3L(w[0],sel[1:0],out[3:0]);
endmodule

module tb;
reg in;
reg [2:0] sel;
wire [7:0] out;
practice dut(in,sel,out);
initial
begin
in=1'b1;
sel=3'b000;
#5
in=1'b1;
sel=3'b001;
#5
in=1'b1;
sel=3'b010;
#5
in=1'b1;
sel=3'b011;
#5
in=1'b1;
sel=3'b100;
#5
in=1'b1;
sel=3'b101;
#5
in=1'b1;
sel=3'b110;
#5
in=1'b1;
sel=3'b111;
end
endmodule
10) 2X4 decoder and two mux and one xor gate
module decoder2X4(a,b,out);
input a,b;
output reg [3:0] out;
always @(a,b)
begin
case({a,b})
2'b00 : out=4'b0001;
2'b01 : out=4'b0010;
2'b10 : out=4'b0100;
2'b11 : out=4'b1000;
endcase
end
endmodule
module mux2X1(a,b,sel,out);
input a,b,sel;
output reg out;
always @(a,b,sel)
begin
if (sel==1'b0)
out=a;
else
out=b;
end
endmodule


module somerandomcircuit(a,b,c,d,out);
input a,b,c,d;
output out;
wire [3:0]w;
wire w1,w2;
decoder2X4 d1(a,b,w);
mux2X1 U(w[3],w[2],c,w1);
mux2X1 D(w[1],w[0],d,w2);
xor(out,w1,w2);
endmodule

module tb;
reg a,b,c,d;
reg check;
wire out;
practice dut(a,b,c,d,out);
initial
begin
a=1'b0;
b=1'b0;
c=1'b0;
d=1'b0;
#0.5
if ( out==(((a)&(~b)&(~d))|((a)&(b)&(d))|((a)&(~b)&(~c))|((~a)&(b)&(c))))
check=1'b1;
else
check=1'b0;
end

endmodule
11) 4 bit SISO shift register
module SISO4bit(in,clk,out);
input in,clk;
output reg out;
reg [2:0]q;
always @(posedge clk)
begin
q[2]<=in;
q[1]<=q[2];
q[0]<=q[1];
out<=q[0];
end

endmodule
module tb;
reg in,clk;
wire out;
practice dut(in,clk,out);
initial
begin
clk=1'b0;
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
end
always #5 clk=~clk;
endmodule

12) 4 bit SIPO shift register

module SIPO4bit(in,clk,out3,out2,out1,out0);
input in,clk;
output reg out3,out2,out1,out0;
always @(posedge clk)
begin
out3<=in;
out2<=out3;
out1<=out2;
out0<=out1;

end
endmodule
module tb;
reg clk,in;
wire out3,out2,out1,out0;
practice dut(in,clk,out3,out2,out1,out0);
initial
begin
clk=1'b0;
in=0;
#40
in=1'b1;
#10
in=1'b1;
#10;
in=1'b0;
#10
in=1'b1;
#10
$stop();
end
always #5 clk=!clk;
endmodule
13) 4 bit PISO shift register
 module piso(in,clk,reset,out);
input [3:0]in;
input clk,reset;
output reg out;
reg [2:0] q;
always @(posedge clk)
begin
if (reset)
begin
q[2]<=in[3];
q[1]<=in[2];
q[0]<=in[1];
out<=in[0];
end
else
begin
q[2]<=1'bx;
q[1]<=q[2];
q[0]<=q[1];
out<=q[0];
end
end
endmodule
module tb;
reg [3:0] in;
reg clk,reset;
wire out;
practice dut(in,clk,reset,out);
initial
begin
clk=1'b0;
reset=1'b1;
in=4'b1001;
#6
reset=1'b0;
end
always #5 clk=~clk;
endmodule

14) 4 bit PIPO shift register

module practice(clk,rst,in,out);
input clk,rst;
input [3:0] in;
output reg [3:0] out;
always @(posedge clk)
begin
if(rst)
begin
out[3]<=in[3];
out[2]<=in[2];
out[1]<=in[1];
out[0]<=in[0];
end
else
begin
out[3]<=1'b0;
out[2]<=out[3];
out[1]<=out[2];
out[0]<=out[1];
end
end
endmodule

module tb;
reg clk,rst;
reg [3:0] in;
wire [3:0] out;
practice dut(clk,rst,in,out);
initial
begin
clk=1'b0;
rst=1'b1;
in=4'b1101;
#6
rst=1'b0;
end
always #5 clk=~clk;
endmodule
15) 4 bit asynchronous Simultaneous “Up” and “Down” Counter
module jkf(j,k,clk,out,outbar,rst);
input j,k,clk,rst;
output reg out,outbar;
wire w1,w2,w3,w4;
always @(posedge clk)
begin
if(rst==1'b1)
begin
out<=1'b0;
outbar<=1'b1;
end
else if(j==1'b0 && k==1'b1)
begin
out<=1'b0;
outbar<=1'b1;
end
else if(j==1'b1 && k==1'b0)
begin
out<=1'b1;
outbar<=1'b0;
end
else if(j==1'b1 && k==1'b1)
begin
out<=~out;
outbar<=~outbar;
end
else
begin
out<=out;
outbar<=outbar;
end

end
endmodule


module asyncountre(clk,rst,outup,outdown);
input clk,rst;
output [3:0] outup,outdown;
jkf d1(1'b1,1'b1,clk,outup[0],outdown[0],rst);
jkf d2(1'b1,1'b1,outdown[0],outup[1],outdown[1],rst);
jkf d3(1'b1,1'b1,outdown[1],outup[2],outdown[2],rst);
jkf d4(1'b1,1'b1,outdown[2],outup[3],outdown[3],rst);

endmodule

module tb;
reg clk,rst;
wire [3:0] outup,outdown;
practice dut(clk,rst,outup,outdown);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
end
always #5 clk=~clk;
endmodule

16) MOD 10 Asynchronous counter 
The below code work fine on simulator(eda playground but not in quartus prime)

module asycounter10(clk,out,rst);
input clk,rst;
output reg [3:0] out;
wire w;
always @(negedge clk or posedge w)
begin
if(rst==1'b1 || w==1'b1 )
out[0]<=1'b0;
else
out[0]<=~out[0];
end
always @(negedge out[0] or posedge w)
begin
if(rst==1'b1 || w==1'b1)
out[1]<=1'b0;
else
out[1]<=~out[1];
end
always @(negedge out[1] or posedge w )
begin
if(rst==1'b1 || w==1'b1)
out[2]<=1'b0;
else
out[2]<=~out[2];
end
always @(negedge out[2] or posedge w )
begin
if(rst==1'b1 || w==1'b1)
out[3]<=1'b0;
else
out[3]<=~out[3];
end
assign  #1 w=out[3]&out[1];//provide delay for correct operation
endmodule

module tb;
reg clk,rst;
wire [3:0] out;
asycounter10 dut(clk,out,rst);
initial
begin
clk=1'b0;
rst=1'b0;
#11
rst=1'b1;
#22
rst=1'b0;
end
always #5 clk=~clk;
endmodule

17) Dual Edge Triggered Flip Flop

module DDFF(in,out,clk,rst);
input in,clk,rst;
output reg out;
reg q1,q2;
always @(posedge clk)
begin
if (rst)
q1<=0;
else
q1<=in;
end
always @(negedge clk)
begin
if (rst)
q2<=0;
else
q2<=in;
end
always @(q1,q2,clk)
begin
if (clk==1'b1)
out=q1;
else
out=q2;
end
endmodule

module tb;
reg in,clk,rst;
wire out;
DDFF dut(in,out,clk,rst);
initial
begin
clk=1'b0;
rst=1'b1;
in=1'b1;
#11
rst=1'b0;
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
end
always #5 clk=~clk;
endmodule

18) Design synchronous counter for the 3-7-0-6-4-1 sequence using D Flip Flop

module syncounter(clk,rst,q);
input clk,rst;
output reg [3:1] q;
always @(posedge clk)
begin
if(rst)
q<=3'b011;
else
begin
q[3]<=((~q[3])&q[2])|(q[2]&(~q[1]))|((~q[3])&(~q[1]));
q[2]<=~q[3];
q[1]<=((~q[3])&q[1])|(q[3]&(~q[2]));
end
end
endmodule
module tb;
reg clk,rst;
wire [3:1] q;
syncounter dut(clk,rst,q);
initial
begin
clk=1'b0;
rst=1'b1;
#7
rst=1'b0;
end
always # 5 clk=~clk;
endmodule

19) 4bit johnson counter

module DFF(clk,rst,in,out,outbar);
input clk,rst,in;
output reg out,outbar;
always @(posedge clk)
begin
if(rst)
begin
out<=1'b0;
outbar<=1'b1;
end
else
begin
out<=in;
outbar<=~in;
end
end
endmodule
module johncounter(clk,rst,out,outbar);
input clk,rst;
output [3:0] out,outbar;
DFF d3(clk,rst,outbar[0],out[3],outbar[3]);
DFF d2(clk,rst,out[3],out[2],outbar[2]);
DFF d1(clk,rst,out[2],out[1],outbar[1]);
DFF d0(clk,rst,out[1],out[0],outbar[0]);
endmodule

module tb;
reg clk,rst;
wire [3:0] out,outbar;
johncounter dut(clk,rst,out,outbar);
initial
begin
clk=1'b0;
rst=1'b1;
#7
rst=1'b0;
end
always #5 clk=~clk;
endmodule









































