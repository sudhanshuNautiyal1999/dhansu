1) 3 to 8 decoder
module decoder3X8(in,out);
input [2:0] in;
output [7:0] out;
reg [7:0]out;
always @(*)
begin
case (in)
3'b000: out=8'b00000001;
3'b001: out=8'b00000010;
3'b010: out=8'b00000100;
3'b011: out=8'b00001000;
3'b100: out=8'b00010000;
3'b101: out=8'b00100000;
3'b110: out=8'b01000000;
3'b111: out=8'b10000000;
default : out=8'b00000000;

endcase

end

endmodule
module test;
reg [2:0]in;
wire [7:0]out;
integer i;
decoder3X8 dut(in,out);
initial
begin
for (i=0;i<8;i=i+1)
begin
in=i;
#10;
end
end
endmodule
2) 8 bit graycounter 
module graycounteightbit(clk,out,rst);
input clk,rst;
output reg [2:0] out;
reg [2:0]count;
always @(posedge clk)
begin
if (rst)
begin
count<=3'b000;
out<=3'b000;
end
else
begin
count<=count+1'b1;
out[2]<=count[2];
out[1]<=count[2]^count[1];
out[0]<=count[1]^count[0];
end
end
endmodule
module test;
reg clk,rst;
wire [2:0]out;
practice dut(clk,out,rst);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
end
always #5 clk=~clk;
endmodule
3) half adder using 4X1 mux
module mux4X1(in1,in2,in3,in4,sel1,sel2,out);
input in1,in2,in3,in4,sel1,sel2;
output reg out;
always @(*)
begin
if ({sel1,sel2}==2'b00)
out=in1;
else if ({sel1,sel2}==2'b01)
out=in2;
else if ({sel1,sel2}==2'b10)
out=in3;
else if ({sel1,sel2}==2'b11)
out=in4;
end
endmodule

module halfadderusingmux(x,y,sum,carry);
input x,y;
output sum,carry;
mux4X1 d1(0,1,1,0,x,y,sum);
mux4X1 d2(0,0,0,1,x,y,carry);
endmodule

module test;
reg x,y;
wire sum,carry;
practice dut(x,y,sum,carry);
initial
begin
x=1'b0;
y=1'b0;
#10
x=1'b0;
y=1'b1;
#10
x=1'b1;
y=1'b0;
#10
x=1'b1;
y=1'b1;
end
endmodule
4) 8 X 3 Priority Encoder
 module prioencder(in,out);
input [7:0]in;
output reg [2:0]out;
always @(*)
begin
casex(in)
8'b00000001 : out = 3'b000;
8'b0000001x : out = 3'b001;
8'b000001xx : out = 3'b010;
8'b00001xxx : out = 3'b011;
8'b0001xxxx : out = 3'b100;
8'b001xxxxx : out = 3'b101;
8'b01xxxxxx : out = 3'b110;
8'b1xxxxxxx : out = 3'b111;
default : out=3'bxxx;
endcase
end
endmodule
module test;
reg [7:0]in;
wire [2:0]out;
practice dut(in,out);
initial
begin
in=8'b11001100; #10;
in=8'b01100110; #10;
in=8'b00110011; #10;
in=8'b00010010; #10;
in=8'b00001001; #10;
in=8'b00000100; #10;
in=8'b00000011; #10;
in=8'b00000001; #10;
in=8'b00000000; # 10; 
end
endmodule
5) 8_bit_barrel_shifter

module mux2X1(in0,in1,out,sel);
input in0,in1,sel;
output out;
wire w1,w2,w3;
not(w1,sel);
and(w2,w1,in0);
and(w3,sel,in1);
or(out,w2,w3);
endmodule

module barrel8bitshifter(in,out,s);
input [7:0] in;
input [2:0] s;
output [7:0] out;
wire [15:0]w;
mux2X1 one(in[7],in[0],w[0],s[0]);
mux2X1 two(in[6],in[7],w[1],s[0]);
mux2X1 three(in[5],in[6],w[2],s[0]);
mux2X1 four(in[4],in[5],w[3],s[0]);
mux2X1 five(in[3],in[4],w[4],s[0]);
mux2X1 six(in[2],in[3],w[5],s[0]);
mux2X1 seven(in[1],in[2],w[6],s[0]);
mux2X1 eight(in[0],in[1],w[7],s[0]);

mux2X1 one1(w[0],w[6],w[8],s[1]);
mux2X1 two2(w[1],w[7],w[9],s[1]);
mux2X1 three3(w[2],w[0],w[10],s[1]);
mux2X1 four4(w[3],w[1],w[11],s[1]);
mux2X1 five5(w[4],w[2],w[12],s[1]);
mux2X1 six6(w[5],w[3],w[13],s[1]);
mux2X1 seven7(w[6],w[4],w[14],s[1]);
mux2X1 eight8(w[7],w[5],w[15],s[1]);

mux2X1 one11(w[8],w[12],out[7],s[2]);
mux2X1 two22(w[9],w[13],out[6],s[2]);
mux2X1 three33(w[10],w[14],out[5],s[2]);
mux2X1 four44(w[11],w[15],out[4],s[2]);
mux2X1 five55(w[12],w[8],out[3],s[2]);
mux2X1 six66(w[13],w[9],out[2],s[2]);
mux2X1 seven77(w[14],w[10],out[1],s[2]);
mux2X1 eight88(w[15],w[11],out[0],s[2]);


endmodule
module tb;
reg [7:0] in;
reg [2:0] s;
wire [7:0] out;
practice dut(in,out,s);
initial
begin
in=8'b00001111;
s=3'b000;
#10
in=8'b00001111;
s=3'b001;
#10
in=8'b00001111;
s=3'b010;
#10
in=8'b00001111;
s=3'b011;
#10
in=8'b00001111;
s=3'b100;
#10
in=8'b00001111;
s=3'b101;
#10
in=8'b00001111;
s=3'b110;
#10
in=8'b00001111;
s=3'b111;

end
endmodule
S0 S1 S2 input      output
0  0  0  00001111   00001111
0  0  1  00001111   10000111
0  1  0  00001111   11000011
0  1  1  00001111   11100001
1  0  0  00001111   11110000
1  0  1  00001111   01111000
1  1  0  00001111   00111100
1  1  1  00001111   00011110
6) 4*4 muliplier

module Halfadder(a,b,s,c);
input a,b;
output s,c;
xor(s,a,b);
and(c,a,b);
endmodule

module Fulladder(a,b,cin,sum,cout);
input a,b,cin;
output sum,cout;
wire w1,w2,w3;
Halfadder HA1(a,b,w1,w2);
Halfadder HA2(w1,cin,sum,w3);
or(cout,w2,w3);
endmodule

module multiplier4X4(a,b,out);
input [3:0] a,b;
output [7:0] out;
wire [32:0] w;
and(out[0],a[0],b[0]);
and(w[1],a[1],b[0]);
and(w[2],a[0],b[1]);
and(w[3],a[1],b[1]);
and(w[4],a[2],b[0]);
and(w[5],a[2],b[1]);
and(w[6],a[3],b[0]);
and(w[12],a[0],b[2]);
and(w[14],a[1],b[2]);
and(w[17],a[3],b[1]);
and(w[20],a[0],b[3]);
and(w[22],a[2],b[2]);
and(w[25],a[3],b[2]);
and(w[28],a[1],b[3]);
and(w[30],a[2],b[3]);
and(w[32],a[3],b[3]);
Halfadder HA3(w[1],w[2],out[1],w[7]);
Fulladder FA1(w[3],w[4],w[7],w[8] ,w[9]);
Fulladder FA2(w[5],w[6],w[9],w[10],w[11]);
Halfadder HA4(w[12],w[8],out[2],w[13]);
Fulladder FA3(w[14],w[10],w[13],w[15],w[16]);
Fulladder FA4(w[17],w[11],w[16],w[18],w[19]);
Halfadder HA5(w[20],w[15],out[3],w[21]);
Fulladder FA5(w[22],w[21],w[18],w[23],w[24]);
Fulladder FA6(w[25],w[24],w[19],w[26],w[27]);
Halfadder HA6(w[28],w[23],out[4],w[29]);
Fulladder FA7(w[30],w[29],w[26],out[5],w[31]);
Fulladder FA8(w[32],w[31],w[27],out[6],out[7]);
endmodule
module test;
reg [3:0] a,b;
wire [7:0] out;
practice dut(a,b,out);
initial
begin
a=4'b1000;
b=4'b1000;
#10
a=4'b1010;
b=4'b0011;
#10
a=4'b0001;
b=4'b0001;
#10
a=4'b0001;
b=4'b0000;
#10
a=4'b1101;
b=4'b0011;
#10
a=4'b1111;
b=4'b1111;
#10
a=4'b0000;
b=4'b0000;
#10
a=4'b1001;
b=4'b1001;

end
endmodule
7) 4 bit carry select adder

module Fulladder(a,b,cin,sum,cout);
input a,b,cin;
output sum,cout;
wire [2:0] w;
xor(w[0],a,b);
xor(sum,w[0],cin);
and(w[1],w[0],cin);
and(w[2],a,b);
or(cout,w[1],w[2]);
endmodule

module mux2X1(in1,in2,sel,out);
input in1,in2,sel;
output out;
wire [2:0]w;
not(w[0],sel);
and(w[1],in2,sel);
and(w[2],in1,w[0]);
or(out,w[1],w[2]);
endmodule
module carryselectadder(a,b,sum,cout);
input [3:0]a,b;
output cout;
output [3:0]sum;
wire [15:0] w;
Fulladder FA1(a[0],b[0],1'b0,w[0],w[1]);
Fulladder FA2(a[1],b[1],w[1],w[2],w[3]);
Fulladder FA3(a[2],b[2],w[3],w[4],w[5]);
Fulladder FA4(a[3],b[3],w[5],w[6],w[13]);

Fulladder FA5(a[0],b[0],1'b1,w[7],w[8]);
Fulladder FA6(a[1],b[1],w[8],w[9],w[10]);
Fulladder FA7(a[2],b[2],w[10],w[11],w[12]);
Fulladder FA8(a[3],b[3],w[12],w[14],w[15]);

mux2X1 MUX1(w[0],w[7],1'b0,sum[0]);
mux2X1 MUX2(w[2],w[9],1'b0,sum[1]);
mux2X1 MUX3(w[4],w[11],1'b0,sum[2]);
mux2X1 MUX4(w[6],w[14],1'b0,sum[3]);
mux2X1 MUX5(w[13],w[15],1'b0,cout);
endmodule

module tb;
reg [3:0]a,b;
wire cout;
wire [3:0] sum;
carryselectadder dut(a,b,sum,cout);
initial
begin
a=4'b1010;
b=4'b0001;
end
endmodule
8) 8X1 mux using 2:4 decoder

module decoder(in1,in2,q);
input in1,in2;
output reg [3:0]q;
always @(in1,in2)
begin
case({in1,in2})
2'b00 : q=4'b0001;
2'b01 : q=4'b0010;
2'b10 : q=4'b0100;
2'b11 : q=4'b1000;
endcase
end
endmodule

module mux(enable,in1,in2,sel,out);
input enable,in1,in2,sel;
output reg out;
always @(enable,in1,in2,sel)
begin
if (enable)
begin
if (sel==1'b0)
out=in1;
else
out=in2;
end
else
out=1'b0;
end
endmodule

module 8X1muxusingdecoder(in,sel,out);
input [7:0] in;
input [2:0] sel;
output out;
wire [3:0]w,o;
decoder d1(sel[2],sel[1],w);
mux m1(w[0],in[0],in[1],sel[0],o[0]);
mux m2(w[1],in[2],in[3],sel[0],o[1]);
mux m3(w[2],in[4],in[5],sel[0],o[2]);
mux m4(w[3],in[6],in[7],sel[0],o[3]);
or(out,o[0],o[1],o[2],o[3]);
endmodule
module tb;
reg [7:0] in;
reg [2:0] sel;
wire out;
practice dut(in,sel,out);
initial
begin
sel=3'b000;
in=8'b00000001;
#10
sel=3'b001;
in=8'b00101001;
#10
sel=3'b111;
in=8'b10000000;
#10
sel=3'b101;
in=8'b00100000;
end
endmodule
9) 1X8 demux using 1X4 demux and 1X2 demux

module demux1X2(in,sel,out);
input in,sel;
output reg [1:0]out;
always @(in,sel)
begin
if (sel==1'b0)
begin
out[0]=in;
out[1]=1'b0;
end
else
begin
out[1]=in;
out[0]=1'b0;
end
end
endmodule

module demux1X4(in,sel,out);
input in;
input [1:0] sel;
output reg [3:0] out;
always @(in,sel)
begin
if (sel==2'b00)
begin
out[0]=in;
out[1]=1'b0;
out[2]=1'b0;
out[3]=1'b0;
end
else if (sel==2'b01)
begin
out[0]=1'b0;
out[1]=in;
out[2]=1'b0;
out[3]=1'b0;
end
else if (sel==2'b10)
begin
out[0]=1'b0;
out[1]=1'b0;
out[2]=in;
out[3]=1'b0;
end
else
begin
out[0]=1'b0;
out[1]=1'b0;
out[2]=1'b0;
out[3]=in;
end
end
endmodule

module demux1X8(in,sel,out);
input in;
input [2:0]sel;
output [7:0]out;
wire [1:0]w;
demux1X2 d1(in,sel[2],w);
demux1X4 d2U(w[1],sel[1:0],out[7:4]);
demux1X4 d3L(w[0],sel[1:0],out[3:0]);
endmodule

module tb;
reg in;
reg [2:0] sel;
wire [7:0] out;
practice dut(in,sel,out);
initial
begin
in=1'b1;
sel=3'b000;
#5
in=1'b1;
sel=3'b001;
#5
in=1'b1;
sel=3'b010;
#5
in=1'b1;
sel=3'b011;
#5
in=1'b1;
sel=3'b100;
#5
in=1'b1;
sel=3'b101;
#5
in=1'b1;
sel=3'b110;
#5
in=1'b1;
sel=3'b111;
end
endmodule
10) 2X4 decoder and two mux and one xor gate
module decoder2X4(a,b,out);
input a,b;
output reg [3:0] out;
always @(a,b)
begin
case({a,b})
2'b00 : out=4'b0001;
2'b01 : out=4'b0010;
2'b10 : out=4'b0100;
2'b11 : out=4'b1000;
endcase
end
endmodule
module mux2X1(a,b,sel,out);
input a,b,sel;
output reg out;
always @(a,b,sel)
begin
if (sel==1'b0)
out=a;
else
out=b;
end
endmodule


module somerandomcircuit(a,b,c,d,out);
input a,b,c,d;
output out;
wire [3:0]w;
wire w1,w2;
decoder2X4 d1(a,b,w);
mux2X1 U(w[3],w[2],c,w1);
mux2X1 D(w[1],w[0],d,w2);
xor(out,w1,w2);
endmodule

module tb;
reg a,b,c,d;
reg check;
wire out;
practice dut(a,b,c,d,out);
initial
begin
a=1'b0;
b=1'b0;
c=1'b0;
d=1'b0;
#0.5
if ( out==(((a)&(~b)&(~d))|((a)&(b)&(d))|((a)&(~b)&(~c))|((~a)&(b)&(c))))
check=1'b1;
else
check=1'b0;
end

endmodule
11) 4 bit SISO shift register
module SISO4bit(in,clk,out);
input in,clk;
output reg out;
reg [2:0]q;
always @(posedge clk)
begin
q[2]<=in;
q[1]<=q[2];
q[0]<=q[1];
out<=q[0];
end

endmodule
module tb;
reg in,clk;
wire out;
practice dut(in,clk,out);
initial
begin
clk=1'b0;
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
end
always #5 clk=~clk;
endmodule

12) 4 bit SIPO shift register

module SIPO4bit(in,clk,out3,out2,out1,out0);
input in,clk;
output reg out3,out2,out1,out0;
always @(posedge clk)
begin
out3<=in;
out2<=out3;
out1<=out2;
out0<=out1;

end
endmodule
module tb;
reg clk,in;
wire out3,out2,out1,out0;
practice dut(in,clk,out3,out2,out1,out0);
initial
begin
clk=1'b0;
in=0;
#40
in=1'b1;
#10
in=1'b1;
#10;
in=1'b0;
#10
in=1'b1;
#10
$stop();
end
always #5 clk=!clk;
endmodule
13) 4 bit PISO shift register
 module piso(in,clk,reset,out);
input [3:0]in;
input clk,reset;
output reg out;
reg [2:0] q;
always @(posedge clk)
begin
if (reset)
begin
q[2]<=in[3];
q[1]<=in[2];
q[0]<=in[1];
out<=in[0];
end
else
begin
q[2]<=1'bx;
q[1]<=q[2];
q[0]<=q[1];
out<=q[0];
end
end
endmodule
module tb;
reg [3:0] in;
reg clk,reset;
wire out;
practice dut(in,clk,reset,out);
initial
begin
clk=1'b0;
reset=1'b1;
in=4'b1001;
#6
reset=1'b0;
end
always #5 clk=~clk;
endmodule

14) 4 bit PIPO shift register

module practice(clk,rst,in,out);
input clk,rst;
input [3:0] in;
output reg [3:0] out;
always @(posedge clk)
begin
if(rst)
begin
out[3]<=in[3];
out[2]<=in[2];
out[1]<=in[1];
out[0]<=in[0];
end
else
begin
out[3]<=1'b0;
out[2]<=out[3];
out[1]<=out[2];
out[0]<=out[1];
end
end
endmodule

module tb;
reg clk,rst;
reg [3:0] in;
wire [3:0] out;
practice dut(clk,rst,in,out);
initial
begin
clk=1'b0;
rst=1'b1;
in=4'b1101;
#6
rst=1'b0;
end
always #5 clk=~clk;
endmodule
15) 4 bit asynchronous Simultaneous “Up” and “Down” Counter
module jkf(j,k,clk,out,outbar,rst);
input j,k,clk,rst;
output reg out,outbar;
wire w1,w2,w3,w4;
always @(posedge clk)
begin
if(rst==1'b1)
begin
out<=1'b0;
outbar<=1'b1;
end
else if(j==1'b0 && k==1'b1)
begin
out<=1'b0;
outbar<=1'b1;
end
else if(j==1'b1 && k==1'b0)
begin
out<=1'b1;
outbar<=1'b0;
end
else if(j==1'b1 && k==1'b1)
begin
out<=~out;
outbar<=~outbar;
end
else
begin
out<=out;
outbar<=outbar;
end

end
endmodule


module asyncountre(clk,rst,outup,outdown);
input clk,rst;
output [3:0] outup,outdown;
jkf d1(1'b1,1'b1,clk,outup[0],outdown[0],rst);
jkf d2(1'b1,1'b1,outdown[0],outup[1],outdown[1],rst);
jkf d3(1'b1,1'b1,outdown[1],outup[2],outdown[2],rst);
jkf d4(1'b1,1'b1,outdown[2],outup[3],outdown[3],rst);

endmodule

module tb;
reg clk,rst;
wire [3:0] outup,outdown;
practice dut(clk,rst,outup,outdown);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
end
always #5 clk=~clk;
endmodule

16) MOD 10 Asynchronous counter 
The below code work fine on simulator(eda playground but not in quartus prime)

module asycounter10(clk,out,rst);
input clk,rst;
output reg [3:0] out;
wire w;
always @(negedge clk or posedge w)
begin
if(rst==1'b1 || w==1'b1 )
out[0]<=1'b0;
else
out[0]<=~out[0];
end
always @(negedge out[0] or posedge w)
begin
if(rst==1'b1 || w==1'b1)
out[1]<=1'b0;
else
out[1]<=~out[1];
end
always @(negedge out[1] or posedge w )
begin
if(rst==1'b1 || w==1'b1)
out[2]<=1'b0;
else
out[2]<=~out[2];
end
always @(negedge out[2] or posedge w )
begin
if(rst==1'b1 || w==1'b1)
out[3]<=1'b0;
else
out[3]<=~out[3];
end
assign  #1 w=out[3]&out[1];//provide delay for correct operation
endmodule

module tb;
reg clk,rst;
wire [3:0] out;
asycounter10 dut(clk,out,rst);
initial
begin
clk=1'b0;
rst=1'b0;
#11
rst=1'b1;
#22
rst=1'b0;
end
always #5 clk=~clk;
endmodule

17) Dual Edge Triggered Flip Flop

module DDFF(in,out,clk,rst);
input in,clk,rst;
output reg out;
reg q1,q2;
always @(posedge clk)
begin
if (rst)
q1<=0;
else
q1<=in;
end
always @(negedge clk)
begin
if (rst)
q2<=0;
else
q2<=in;
end
always @(q1,q2,clk)
begin
if (clk==1'b1)
out=q1;
else
out=q2;
end
endmodule

module tb;
reg in,clk,rst;
wire out;
DDFF dut(in,out,clk,rst);
initial
begin
clk=1'b0;
rst=1'b1;
in=1'b1;
#11
rst=1'b0;
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
end
always #5 clk=~clk;
endmodule

18) Design synchronous counter for the 3-7-0-6-4-1 sequence using D Flip Flop

module syncounter(clk,rst,q);
input clk,rst;
output reg [3:1] q;
always @(posedge clk)
begin
if(rst)
q<=3'b011;
else
begin
q[3]<=((~q[3])&q[2])|(q[2]&(~q[1]))|((~q[3])&(~q[1]));
q[2]<=~q[3];
q[1]<=((~q[3])&q[1])|(q[3]&(~q[2]));
end
end
endmodule
module tb;
reg clk,rst;
wire [3:1] q;
syncounter dut(clk,rst,q);
initial
begin
clk=1'b0;
rst=1'b1;
#7
rst=1'b0;
end
always # 5 clk=~clk;
endmodule

19) 4bit johnson counter

module DFF(clk,rst,in,out,outbar);
input clk,rst,in;
output reg out,outbar;
always @(posedge clk)
begin
if(rst)
begin
out<=1'b0;
outbar<=1'b1;
end
else
begin
out<=in;
outbar<=~in;
end
end
endmodule
module johncounter(clk,rst,out,outbar);
input clk,rst;
output [3:0] out,outbar;
DFF d3(clk,rst,outbar[0],out[3],outbar[3]);
DFF d2(clk,rst,out[3],out[2],outbar[2]);
DFF d1(clk,rst,out[2],out[1],outbar[1]);
DFF d0(clk,rst,out[1],out[0],outbar[0]);
endmodule

module tb;
reg clk,rst;
wire [3:0] out,outbar;
johncounter dut(clk,rst,out,outbar);
initial
begin
clk=1'b0;
rst=1'b1;
#7
rst=1'b0;
end
always #5 clk=~clk;
endmodule

20) 4 bit LFSR circuit
(https://inst.eecs.berkeley.edu/~cs150/sp03/handouts/15/LectureA/lec27-2up.pdf in this website page 1 you can refe
diagram and output)

module LFSR(clk,rst,q);
input clk,rst;
output reg [3:0] q;
always @(posedge clk)
begin
if(rst)
begin
q[3]<=1'b0;
q[2]<=1'b0;
q[1]<=1'b0;
q[0]<=1'b1;
end
else
begin
q[0]<=q[3];
q[1]<=q[3]^q[0];
q[2]<=q[1];
q[3]<=q[2];
end
end
endmodule

module tb;
reg clk,rst;
wire [3:0] q;
practice LFSR(clk,rst,q);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
end
always # 5 clk=~clk;
endmodule

21) 11011 FSM overlapping Morre machine
 module fsm(clk,rst,in,out);
input clk,rst,in;
output reg out;
parameter A=3'b000,B=3'b001,C=3'b010,D=3'b100,E=3'b111,F=3'b110;
reg [2:0] ps,ns;
always @(posedge clk)
begin
if(rst)
ps<=A;
else
ps<=ns;
end
always @(ps,in)
begin
case(ps)
A : begin
ns=in?B:A;
out=1'b0;
end
B : begin
ns=in?C:A;
out=1'b0;
end
C : begin
ns=in?C:D;
out=1'b0;
end
D : begin
ns=in?E:A;
out=1'b0;
end
E : begin
ns=in?F:A;
out=1'b0;
end
F : begin
ns=in?C:D;
out=1'b1;
end
endcase
end
endmodule

module tb;
reg clk,rst,in;
wire out;
fsm dut(clk,rst,in,out);
initial
begin
clk=1'b0;
rst=1'b1;
in=1'b1;
#6
rst=1'b0;
#19
in=1'b1;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b1;
#10;
in=1'b0;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10;
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b1;
end
always #5 clk=~clk;
endmodule

22) 101010  overlapping FSM mealy machine 

module mealy(clk,rst,in,out);
input clk,rst,in;
output reg out;
parameter A=4'b0000,B=4'b0001,C=4'b0010,D=4'b0100,E=4'b1000,F=4'b1100;
reg [3:0] ps,ns;
always @(posedge clk)
begin
if(rst)
ps<=A;
else
ps<=ns;
end

always @(ps,in)
begin
case(ps)
A: begin
ns=in?B:A;
out=1'b0;
end
B: begin
ns=in?B:C;
out=1'b0;
end
C: begin
ns=in?D:A;
out=1'b0;
end
D: begin
ns=in?B:E;
out=1'b0;
end
E: begin
ns=in?F:A;
out=1'b0;
end
F: begin
ns=in?B:E;
out=in?1'b0:1'b1;
end
endcase
end
endmodule

module tb;
reg clk,rst,in;
wire out;
mealy dut(clk,rst,in,out);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
#9
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
end
always #5 clk=~clk;
endmodule

23) 1001 & 010 overlapping mealy FSM

module mealy(clk,rst,in,out);
input clk,rst,in;
output reg out;
parameter S0=4'b0000,S1=4'b0001,S2=4'b0010,S3=4'b0100,S4=4'b1000,S5=4'b1100;
reg [3:0] ns,ps;
always @(posedge clk)
begin
if(rst)
ps<=S0;
else
ps<=ns;
end

always @(ps,in)
begin
case(ps)
S0: begin
ns=in?S1:S4;
out=1'b0;
end
S1: begin
ns=in?S1:S2;
out=1'b0;
end
S2: begin
ns=in?S5:S3;
out=1'b0;
end
S3: begin
ns=in?S5:S4;
out=in?1'b1:1'b0;
end
S4: begin
ns=in?S5:S4;
out=1'b0;
end
S5: begin
ns=in?S1:S2;
out=in?1'b0:1'b1;
end
endcase
end
endmodule

module tb;
reg clk,rst,in;
wire out;
mealy dut(clk,rst,in,out);
initial
begin
clk=1'b0;
rst=1'b1;
in=1'b1;
#6
rst=1'b0;
#9
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
end
always #5 clk=~clk;
endmodule

24) 2's complement of a binary number using Moore FSM

module (clk,rst,in,out);
input clk,rst,in;
output reg out;
parameter A=2'b00,B=2'b01,C=2'b10;
reg [1:0] ps,ns;
always @(posedge clk)
begin
if(rst)
ps<=A;
else
ps<=ns;
end

always @(ps,in)
begin
case(ps)
A : begin
ns=in?B:A;
out=1'b0;
end
B : begin
ns=in?C:B;
out=1'b1;
end
C : begin
ns=in?C:B;
out=1'b0;
end
endcase
end
endmodule

module tb;
reg clk,rst,in;
wire out;
complement dut(clk,rst,in,out);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
#9
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
end
always #5 clk=~clk;
endmodule

25) Vending machine using mealy machine with change
In this, we will get drink bottle when price = 15 , and we have only 5 and 10 avialable

module machine(clk,rst,coin,bottlereceived,change);
input clk,rst;
input [3:0] coin;
output reg bottlereceived;
output reg [3:0] change;
parameter S0=2'b00,S1=2'b01,S2=2'b10;
reg [1:0] ps,ns;

always @(posedge clk)
begin
if(rst)
ps<=S0;
else
ps<=ns;
end

always @(ps,coin)
begin
case(ps)
S0 : begin
ns = (coin==4'b0101) ? S1 : ((coin==4'b1010) ? S2:S0);
bottlereceived = 1'b0;
change = 4'b0000;
end
S1 : begin
ns = (coin==4'b0101) ? S2 : S0;
bottlereceived = (coin==4'b1010) ? 1'b1 : 1'b0;
change = (coin==4'b0000) ? 4'b0101 : 4'b0000;
end
S2 : begin
ns = S0;
bottlereceived = (coin==4'b0101 || coin==4'b1010) ? 1'b1 : 1'b0;
change = (coin==4'b1010)? 4'b0101 : ((coin==4'b0000) ? 4'b1010 : 4'b0000);
end
endcase
end
endmodule

module tb;
reg clk,rst;
reg [3:0] coin;
wire bottlereceived;
wire [3:0] change;
machine dut(clk,rst,coin,bottlereceived,change);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
#9
coin=4'b0101;
#10;
coin=4'b0101;
#10;
coin=4'b0101;
#10;
coin=4'b0101;
#10;
coin=4'b1010;
#10;
coin=4'b1010;
#10;
coin=4'b0101;
#10;
coin=4'b1010;
#10;
coin=4'b1010;
#10;
coin=4'b1010;
#10;
coin=4'b0000;
end
always #5 clk=~clk;
endmodule

26) single port SRAM with Synchronous read/write

module sram(clk,datain,dataout,enablewrite,readaddress,writeaddress);
input clk,enablewrite;
input [7:0] datain;
input [5:0] readaddress,writeaddress;
output reg [7:0] dataout;
reg [7:0] ram [63:0];

always @(posedge clk)
begin
if(enablewrite)
ram[writeaddress]<=datain;
dataout<=ram[readaddress];
end
endmodule

module tb;
reg clk,enablewrite;
reg [5:0] readaddress,writeaddress;
reg [7:0] datain;
wire [7:0] dataout;
sram dut(clk,datain,dataout,enablewrite,readaddress,writeaddress);
initial
begin
clk=1'b0;
enablewrite=1'b0;
datain=8'b00000000;
#12
enablewrite=1'b1;
datain=8'b11110000;
writeaddress=6'b000000;
readaddress=6'b000000;
#10
datain=8'b11111111;
writeaddress=6'b000000;
readaddress=6'b000000;

end
initial
begin
#30
$finish();
end
always #5 clk=~clk;
endmodule

27) Synchronous FIFO

module fifo(clk,rst,wen,ren,data,dataout,full,empty);
input clk,rst,wen,ren;
input [7:0] data;
output reg [7:0] dataout;
output full,empty;
reg [7:0] memory [15:0];
reg [3:0] wrptr,rdptr;
integer i;
always @(posedge clk)
begin
if (rst)
begin
for(i=0;i<16;i=i+1)
memory[i]=8'b00000000;
wrptr<=4'b0000;
dataout<=8'b00000000;
rdptr<=4'b0000;
end
// write
else if (wen==1'b1)
begin
if (wrptr <  4'b1111)
begin
memory[wrptr]<=data;
wrptr<=wrptr+1'b1;
end
else if(wrptr==4'b1111)
begin
memory[wrptr]<=data;
end
end

//read
else if(ren==1'b1)
begin
if(rdptr!=wrptr)
begin
dataout<=memory[rdptr];
memory[rdptr]<=8'b00000000;
rdptr<=rdptr+1'b1;
end
else if(rdptr==wrptr)
begin
dataout<=memory[rdptr];
memory[rdptr]<=8'b00000000;
wrptr<=4'b0000;
rdptr<=4'b0000;
end
end
end
assign empty=(rdptr==wrptr)?1'b1:1'b0;
assign full=(wrptr==4'b1111)?1'b1:1'b0;
endmodule

module tb;
reg clk,rst,wen,ren;
reg [7:0] data;
wire [7:0] dataout;
wire full,empty;
fifo dut(clk,rst,wen,ren,data,dataout,full,empty);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
wen=1'b1;
#9
data=8'b01010101;
#10;
data=8'b10101010;
#10;
data=8'b00001111;
#10;
data=8'b11110000;
#10;
data=8'b00110011;
#10;
data=8'b11001100;
#10;
data=8'b11100011;
#10;
data=8'b00011100;
#5;
wen=1'b0;
#5
ren=1'b1;
end
always #5 clk=~clk;
endmodule

28) Generate output = 1 for 4 clock cycle and for next 4 clock cycle output = 0. Repeat this sequence for forever

module clk4(clk,rst,out);
input clk,rst;
output reg out;
reg [3:0] pose,nege;
always @(posedge clk)
begin
if (rst)
begin
pose=4'b0000;
nege=4'b0000;
out=1'b0;
end
else
begin
if((pose<4'b0100) && ((nege==4'b0000) || (nege>=4'b0100)))
begin
out=1'b1;
pose=pose+1'b1;
nege=4'b0000;
end
else if (pose >= 4'b0100)
begin
out=1'b0;
nege=nege+1'b1;
pose=4'b0000;
end
else if (nege < 4'b0100)
begin
out=1'b0;
nege=nege+1'b1;
pose=4'b0000;
end
end
end
endmodule

module tb;
reg clk,rst;
wire out;
clk4 dut(clk,rst,out);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
end
always # 5 clk=~clk;
endmodule

29) Moore FSM gives output 1 when detects even number of ones recived else output is 0

module even(clk,rst,in,out);
input clk,rst,in;
output reg out;
parameter S0=3'b100,S1=3'b010,S2=3'b001;
reg [2:0] ps,ns;
always @(posedge clk)
begin
if(rst)
ps<=S0;
else
ps<=ns;
end

always @(ps,in)
begin
case(ps)
S0 : begin
ns=in?S1:S0;
out=1'b0;
end
S1 : begin
ns=in?S2:S1;
out=1'b0;
end
S2 : begin
ns=in?S1:S0;
out=1'b1;
end
endcase
end
endmodule

module tb;
reg clk,rst,in;
wire out;
even dut(clk,rst,in,out);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
#9
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b1;
end
always #5 clk=~clk;
endmodule

30) Design a synchronous Traffic light controller cicuit

module trafficlight(clk,rst,red,green,yellow);
input clk,rst;
output  red,green,yellow;
parameter GREEN = 3'b000 ,YELLOW = 3'b001 ,RED = 3'b010 ,REDYELLOW = 3'b100 ,WAITED = 3'b111;
reg [2:0] ps,ns;
reg [5:0] count;

always @(posedge clk)
begin
if(rst)
ps <= GREEN;
else
ps <= ns;
end

always @(ps,count)
begin
case(ps)
GREEN : ns = (count == 6'b001111) ? YELLOW : GREEN;
YELLOW : ns = (count == 6'b010100) ? RED : YELLOW;
RED : ns = (count == 6'b011110) ? REDYELLOW : RED;
REDYELLOW : ns = (count == 6'b100011) ? WAITED : REDYELLOW;
WAITED : ns = GREEN;
endcase
end

always @(posedge clk)
begin
if(rst)
count <= 5'b000000;
else if (ps == WAITED)
count <= 5'b000000;
else
count <= count + 1'b1;
end

assign red = (ps == RED || ps == REDYELLOW) ? 1'b1 : 1'b0;
assign yellow = (ps == YELLOW || ps == REDYELLOW) ? 1'b1 : 1'b0;
assign green = (ps == GREEN) ? 1'b1 : 1'b0;
endmodule

module tb;
reg clk,rst;
wire red,green,yellow;
trafficlight dut(clk,rst,red,green,yellow);

initial
begin
clk = 1'b0;
rst = 1'b1;
#6
rst = 1'b0;

end
always #5 clk = ~clk;
endmodule

31) Lfsr5 ( https://hdlbits.01xz.net/wiki/Lfsr5)
module lfsr5(clk,reset,q);
    input clk,reset;
    output reg [4:0] q;
    always @(posedge clk)
        begin
            if(reset)
                q <= 5'h1;
            else
                begin
                    q[4] <= 1'b0^q[0];
                    q[3] <= q[4];
                    q[2] <= q[0]^q[3];
                    q[1] <= q[2];
                    q[0] <= q[1];
                end
        end
endmodule

32) A 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and
   carry out. (https://hdlbits.01xz.net/wiki/Adder100)

 module Fulladder(in1,in2,carryin,sum,carryout);
    input in1,in2,carryin;
    output sum,carryout;
    assign sum = in1^in2^carryin;
    assign carryout = in2&carryin | (in1)&(in2|carryin);
endmodule


module adder100(a,b,cin,cout,sum);
    input [99:0] a,b;
    input cin;
    output cout;
    output [99:0] sum;
    wire [98:0] w;
    Fulladder f1(a[0],b[0],cin,sum[0],w[0]);
    genvar i;
    generate
        begin
            for( i = 1; i<=98 ; i=i+1)
                begin : adder
                    Fulladder f2(a[i],b[i],w[i-1],sum[i],w[i]);
                end
        end
    endgenerate
    Fulladder f3(a[99],b[99],w[98],sum[99],cout);
endmodule

33) module that outputs a 32 bit number. Write verilog code to grab bits 8-14 bits.

module Grabbits(in,out);

input [31:0] in;

output reg [7:0] out;

reg [31:0] temp;

integer i;

always @(in)

begin

temp = in >> 8;

for( i = 0; i <= 7; i = i+1)
begin

out[i] = temp[0] & 1'b1;

temp = temp >> 1;

end
end

endmodule

module tb;

reg [31:0] in;

wire [7:0] out;

Grabbits dut(in,out);

initial

begin
in = 32'b00000000000000000101010100000000;
end
endmodule

34) Finite state machine (FSM) for an automatic reversible 6 modulo counter as follows: 
    The counter counts 0, 1, 2, 3, 4, 5 (when  input is  0) and reverses: 5 4, 3, 2, 1, 0 
    (when input is 1)

module count0to5(clk,rst,in,out);

input clk,rst,in;
output reg [3:0] out;
parameter A = 4'b0000, B = 4'b0001, C = 4'b0010, D = 4'b0011, E = 4'b0100, F = 4'b0101,  G = 4'b0111, H = 4'b1000,I = 4'b1001, J = 4'b1010, K = 4'b1011, L = 4'b1100;
reg [3:0] ps, ns;

always @(posedge clk)
begin
if(rst)
ps <= A;
else
ps <= ns;
end

always @(ps,in)
begin
case (ps)
A : begin
ns = B;
out = 4'b0000;
end

B : begin
ns = C;
out = 4'b0001;
end

C : begin
ns = D;
out = 4'b0010;
end

D : begin
ns = E;
out = 4'b0011;
end

E : begin
ns = F;
out = 4'b0100;
end

F : begin
ns = in ? G : A;
out = 4'b0101;
end

G : begin
ns = H;
out = 4'b0101;
end

H : begin
ns = I;
out = 4'b0100;
end

I : begin
ns = J;
out = 4'b0011;
end

J : begin
ns = K;
out = 4'b0010;
end

K : begin
ns = L;
out = 4'b0001;
end

L : begin
ns = in ? A : G; 
out = 4'b0000;
end
endcase
end
endmodule

module tb;

reg clk,rst,in;
wire[3:0] out;

count0to5 dut(clk,rst,in,out);

initial
begin
clk = 1'b0;
rst = 1'b1;
in = 1'b1;
#10;
rst = 1'b0;
#60;
in = 1'b0;
end

always # 5 clk = ~clk;

endmodule

35) Simple and basic UART transmitter which transfer 8 bit data frame

module uarttx(clk,rst,data_in,done,data_out,stop_bit,start_bit);

input clk,rst,data_in;
output done,data_out,stop_bit,start_bit;

parameter idle = 3'b000, start = 3'b001, transfer = 3'b010, endd = 3'b100;
reg [2:0] ps,ns;
reg [3:0] count;

always @(posedge clk)
begin
if(rst)
ps <= idle;
else
ps <= ns;
end


always @(ps,data_in,count)
begin
case(ps)
idle : ns = start;
start : ns = data_in ? start : transfer;
transfer : ns = (count == 4'b1000) ? (data_in ? endd : start) : transfer;
endd : ns = data_in ? start : transfer;
endcase
end

always @(posedge clk)
begin
if(rst)
count <= 4'b0000;
else if(ps == transfer)
count <= count + 1'b1;
else
count <= 4'b0000;
end

assign done = (ps == endd) ? 1'b1 : 1'b0;
assign data_out = (ps == transfer) ? data_in : 1'bx;
assign start_bit = (ps == start) ? 1'b1 : 1'b0;
assign stop_bit = (count == 4'b1000) ? data_in : 1'b0; 
endmodule

module tb;
reg clk,rst,data_in;
wire done,data_out,stop_bit,start_bit;
uarttx dut(clk,rst,data_in,done,data_out,stop_bit,start_bit);

initial
begin
clk = 1'b0;
rst = 1'b1;
data_in = 1'b1;
#6
rst = 1'b0;
#19
data_in = 1'b0;
#10
data_in = 1'b1;
#10;
data_in = 1'b1;
#10;
data_in = 1'b1;
#10;
data_in = 1'b1;
#10;
data_in = 1'b1;
#10;
data_in = 1'b1;
#10;
data_in = 1'b1;
#10;
data_in = 1'b0;
#10;
data_in = 1'b1;
#40;
data_in = 1'b0;
#10
data_in = 1'b1;
#10;
data_in = 1'b0;
#10;
data_in = 1'b1;
#10;
data_in = 1'b0;
#10;
data_in = 1'b1;
#10;
data_in = 1'b0;
#10;
data_in = 1'b1;
#10;
data_in = 1'b0;
#10;
data_in = 1'b1;

end

always #5 clk = ~clk;
endmodule

36) Solution to HDLbits problem (https://hdlbits.01xz.net/wiki/Exams/review2015_fsmseq)

module top_module(clk ,reset ,data ,start_shifting);
    input clk,reset,data;
    output start_shifting;
    parameter S0 = 4'b0000 ,S1 = 4'b0001 ,S2 = 4'b0010 ,S3 = 4'b0100 ,S4 = 4'b1000;
    reg [3:0] ps ,ns;
    
    always @(posedge clk)
        begin
            if(reset)
                ps <= S0;
            else
                ps <= ns;
        end
    
    always @(ps,data)
        begin
            case(ps)
                S0 : ns = data ? S1 : S0;
                S1 : ns = data ? S2 : S0;
                S2 : ns = data ? S2 : S3;
                S3 : ns = data ? S4 : S0;
                S4 : ns = S4;
            endcase
        end
    
    assign start_shifting = (ps == S4) ? 1'b1 : 1'b0;
    
endmodule

37) Solution to HDLBITS Exams/2013 q2afsm (https://hdlbits.01xz.net/wiki/Exams/2013_q2afsm)

module top_module (clk ,resetn ,r ,g);
    input clk,resetn;
    input [3:1] r;
    output [3:1] g;
    
    parameter A = 3'b000 ,B = 3'b001 ,C = 3'b010 ,D = 3'b100;
    reg [2:0] ps,ns;
    
    always@(posedge clk)
        if(~resetn)
            ps <= A;
     else
            ps <= ns;
    
    always@(ps ,r)
        case(ps)
            A : ns = r[1] ? B : (r[2] ? C : (r[3] ? D : A));
            B : ns = r[1] ? B :A;
            C : ns = r[2] ? C :A;
            D : ns = r[3] ? D :A;
        endcase
    
    assign g[1] = (ps == B) ? 1'b1 : 1'b0;
    assign g[2] = (ps == C) ? 1'b1 : 1'b0;
    assign g[3] = (ps == D) ? 1'b1 : 1'b0;
    
endmodule

38) HDLbits solution of Lemmings1(https://hdlbits.01xz.net/wiki/Lemmings1)

module top_module(clk ,areset ,bump_left ,bump_right ,walk_left ,walk_right);
    
    input clk ,areset ,bump_left ,bump_right;
    output walk_left ,walk_right;
    
    parameter Left = 2'b00 , Right = 2'b01;
    reg [1:0] ps ,ns;
    
    always @(posedge clk or posedge areset)
        begin
            if(areset)
                ps <= Left;
            else
                ps <= ns;
        end
    
    always @(ps ,bump_left ,bump_right)
        begin
            case(ps)
                Left  : ns = bump_left  ? Right : Left;
                Right : ns = bump_right ? Left  : Right;
            endcase
        end
    
    assign walk_left  = (ps == Left)  ? 1'b1 : 1'b0;
    assign walk_right = (ps == Right) ? 1'b1 : 1'b0;
    
endmodule
    

			 




















































