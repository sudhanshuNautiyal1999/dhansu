1) 3 to 8 decoder
module decoder3X8(in,out);
input [2:0] in;
output [7:0] out;
reg [7:0]out;
always @(*)
begin
case (in)
3'b000: out=8'b00000001;
3'b001: out=8'b00000010;
3'b010: out=8'b00000100;
3'b011: out=8'b00001000;
3'b100: out=8'b00010000;
3'b101: out=8'b00100000;
3'b110: out=8'b01000000;
3'b111: out=8'b10000000;
default : out=8'b00000000;

endcase

end

endmodule
module test;
reg [2:0]in;
wire [7:0]out;
integer i;
decoder3X8 dut(in,out);
initial
begin
for (i=0;i<8;i=i+1)
begin
in=i;
#10;
end
end
endmodule
2) 8 bit graycounter 
module graycounteightbit(clk,out,rst);
input clk,rst;
output reg [2:0] out;
reg [2:0]count;
always @(posedge clk)
begin
if (rst)
begin
count<=3'b000;
out<=3'b000;
end
else
begin
count<=count+1'b1;
out[2]<=count[2];
out[1]<=count[2]^count[1];
out[0]<=count[1]^count[0];
end
end
endmodule
module test;
reg clk,rst;
wire [2:0]out;
practice dut(clk,out,rst);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
end
always #5 clk=~clk;
endmodule
3) half adder using 4X1 mux
module mux4X1(in1,in2,in3,in4,sel1,sel2,out);
input in1,in2,in3,in4,sel1,sel2;
output reg out;
always @(*)
begin
if ({sel1,sel2}==2'b00)
out=in1;
else if ({sel1,sel2}==2'b01)
out=in2;
else if ({sel1,sel2}==2'b10)
out=in3;
else if ({sel1,sel2}==2'b11)
out=in4;
end
endmodule

module halfadderusingmux(x,y,sum,carry);
input x,y;
output sum,carry;
mux4X1 d1(0,1,1,0,x,y,sum);
mux4X1 d2(0,0,0,1,x,y,carry);
endmodule

module test;
reg x,y;
wire sum,carry;
practice dut(x,y,sum,carry);
initial
begin
x=1'b0;
y=1'b0;
#10
x=1'b0;
y=1'b1;
#10
x=1'b1;
y=1'b0;
#10
x=1'b1;
y=1'b1;
end
endmodule
4) 8 X 3 Priority Encoder
 module prioencder(in,out);
input [7:0]in;
output reg [2:0]out;
always @(*)
begin
casex(in)
8'b00000001 : out = 3'b000;
8'b0000001x : out = 3'b001;
8'b000001xx : out = 3'b010;
8'b00001xxx : out = 3'b011;
8'b0001xxxx : out = 3'b100;
8'b001xxxxx : out = 3'b101;
8'b01xxxxxx : out = 3'b110;
8'b1xxxxxxx : out = 3'b111;
default : out=3'bxxx;
endcase
end
endmodule
module test;
reg [7:0]in;
wire [2:0]out;
practice dut(in,out);
initial
begin
in=8'b11001100; #10;
in=8'b01100110; #10;
in=8'b00110011; #10;
in=8'b00010010; #10;
in=8'b00001001; #10;
in=8'b00000100; #10;
in=8'b00000011; #10;
in=8'b00000001; #10;
in=8'b00000000; # 10; 
end
endmodule
5) 8_bit_barrel_shifter

module mux2X1(in0,in1,out,sel);
input in0,in1,sel;
output out;
wire w1,w2,w3;
not(w1,sel);
and(w2,w1,in0);
and(w3,sel,in1);
or(out,w2,w3);
endmodule

module barrel8bitshifter(in,out,s);
input [7:0] in;
input [2:0] s;
output [7:0] out;
wire [15:0]w;
mux2X1 one(in[7],in[0],w[0],s[0]);
mux2X1 two(in[6],in[7],w[1],s[0]);
mux2X1 three(in[5],in[6],w[2],s[0]);
mux2X1 four(in[4],in[5],w[3],s[0]);
mux2X1 five(in[3],in[4],w[4],s[0]);
mux2X1 six(in[2],in[3],w[5],s[0]);
mux2X1 seven(in[1],in[2],w[6],s[0]);
mux2X1 eight(in[0],in[1],w[7],s[0]);

mux2X1 one1(w[0],w[6],w[8],s[1]);
mux2X1 two2(w[1],w[7],w[9],s[1]);
mux2X1 three3(w[2],w[0],w[10],s[1]);
mux2X1 four4(w[3],w[1],w[11],s[1]);
mux2X1 five5(w[4],w[2],w[12],s[1]);
mux2X1 six6(w[5],w[3],w[13],s[1]);
mux2X1 seven7(w[6],w[4],w[14],s[1]);
mux2X1 eight8(w[7],w[5],w[15],s[1]);

mux2X1 one11(w[8],w[12],out[7],s[2]);
mux2X1 two22(w[9],w[13],out[6],s[2]);
mux2X1 three33(w[10],w[14],out[5],s[2]);
mux2X1 four44(w[11],w[15],out[4],s[2]);
mux2X1 five55(w[12],w[8],out[3],s[2]);
mux2X1 six66(w[13],w[9],out[2],s[2]);
mux2X1 seven77(w[14],w[10],out[1],s[2]);
mux2X1 eight88(w[15],w[11],out[0],s[2]);


endmodule
module tb;
reg [7:0] in;
reg [2:0] s;
wire [7:0] out;
practice dut(in,out,s);
initial
begin
in=8'b00001111;
s=3'b000;
#10
in=8'b00001111;
s=3'b001;
#10
in=8'b00001111;
s=3'b010;
#10
in=8'b00001111;
s=3'b011;
#10
in=8'b00001111;
s=3'b100;
#10
in=8'b00001111;
s=3'b101;
#10
in=8'b00001111;
s=3'b110;
#10
in=8'b00001111;
s=3'b111;

end
endmodule
S0 S1 S2 input      output
0  0  0  00001111   00001111
0  0  1  00001111   10000111
0  1  0  00001111   11000011
0  1  1  00001111   11100001
1  0  0  00001111   11110000
1  0  1  00001111   01111000
1  1  0  00001111   00111100
1  1  1  00001111   00011110
6) 4*4 muliplier

module Halfadder(a,b,s,c);
input a,b;
output s,c;
xor(s,a,b);
and(c,a,b);
endmodule

module Fulladder(a,b,cin,sum,cout);
input a,b,cin;
output sum,cout;
wire w1,w2,w3;
Halfadder HA1(a,b,w1,w2);
Halfadder HA2(w1,cin,sum,w3);
or(cout,w2,w3);
endmodule

module multiplier4X4(a,b,out);
input [3:0] a,b;
output [7:0] out;
wire [32:0] w;
and(out[0],a[0],b[0]);
and(w[1],a[1],b[0]);
and(w[2],a[0],b[1]);
and(w[3],a[1],b[1]);
and(w[4],a[2],b[0]);
and(w[5],a[2],b[1]);
and(w[6],a[3],b[0]);
and(w[12],a[0],b[2]);
and(w[14],a[1],b[2]);
and(w[17],a[3],b[1]);
and(w[20],a[0],b[3]);
and(w[22],a[2],b[2]);
and(w[25],a[3],b[2]);
and(w[28],a[1],b[3]);
and(w[30],a[2],b[3]);
and(w[32],a[3],b[3]);
Halfadder HA3(w[1],w[2],out[1],w[7]);
Fulladder FA1(w[3],w[4],w[7],w[8] ,w[9]);
Fulladder FA2(w[5],w[6],w[9],w[10],w[11]);
Halfadder HA4(w[12],w[8],out[2],w[13]);
Fulladder FA3(w[14],w[10],w[13],w[15],w[16]);
Fulladder FA4(w[17],w[11],w[16],w[18],w[19]);
Halfadder HA5(w[20],w[15],out[3],w[21]);
Fulladder FA5(w[22],w[21],w[18],w[23],w[24]);
Fulladder FA6(w[25],w[24],w[19],w[26],w[27]);
Halfadder HA6(w[28],w[23],out[4],w[29]);
Fulladder FA7(w[30],w[29],w[26],out[5],w[31]);
Fulladder FA8(w[32],w[31],w[27],out[6],out[7]);
endmodule
module test;
reg [3:0] a,b;
wire [7:0] out;
practice dut(a,b,out);
initial
begin
a=4'b1000;
b=4'b1000;
#10
a=4'b1010;
b=4'b0011;
#10
a=4'b0001;
b=4'b0001;
#10
a=4'b0001;
b=4'b0000;
#10
a=4'b1101;
b=4'b0011;
#10
a=4'b1111;
b=4'b1111;
#10
a=4'b0000;
b=4'b0000;
#10
a=4'b1001;
b=4'b1001;

end
endmodule
7) 4 bit carry select adder

module Fulladder(a,b,cin,sum,cout);
input a,b,cin;
output sum,cout;
wire [2:0] w;
xor(w[0],a,b);
xor(sum,w[0],cin);
and(w[1],w[0],cin);
and(w[2],a,b);
or(cout,w[1],w[2]);
endmodule

module mux2X1(in1,in2,sel,out);
input in1,in2,sel;
output out;
wire [2:0]w;
not(w[0],sel);
and(w[1],in2,sel);
and(w[2],in1,w[0]);
or(out,w[1],w[2]);
endmodule
module carryselectadder(a,b,sum,cout);
input [3:0]a,b;
output cout;
output [3:0]sum;
wire [15:0] w;
Fulladder FA1(a[0],b[0],1'b0,w[0],w[1]);
Fulladder FA2(a[1],b[1],w[1],w[2],w[3]);
Fulladder FA3(a[2],b[2],w[3],w[4],w[5]);
Fulladder FA4(a[3],b[3],w[5],w[6],w[13]);

Fulladder FA5(a[0],b[0],1'b1,w[7],w[8]);
Fulladder FA6(a[1],b[1],w[8],w[9],w[10]);
Fulladder FA7(a[2],b[2],w[10],w[11],w[12]);
Fulladder FA8(a[3],b[3],w[12],w[14],w[15]);

mux2X1 MUX1(w[0],w[7],1'b0,sum[0]);
mux2X1 MUX2(w[2],w[9],1'b0,sum[1]);
mux2X1 MUX3(w[4],w[11],1'b0,sum[2]);
mux2X1 MUX4(w[6],w[14],1'b0,sum[3]);
mux2X1 MUX5(w[13],w[15],1'b0,cout);
endmodule

module tb;
reg [3:0]a,b;
wire cout;
wire [3:0] sum;
carryselectadder dut(a,b,sum,cout);
initial
begin
a=4'b1010;
b=4'b0001;
end
endmodule
8) 8X1 mux using 2:4 decoder

module decoder(in1,in2,q);
input in1,in2;
output reg [3:0]q;
always @(in1,in2)
begin
case({in1,in2})
2'b00 : q=4'b0001;
2'b01 : q=4'b0010;
2'b10 : q=4'b0100;
2'b11 : q=4'b1000;
endcase
end
endmodule

module mux(enable,in1,in2,sel,out);
input enable,in1,in2,sel;
output reg out;
always @(enable,in1,in2,sel)
begin
if (enable)
begin
if (sel==1'b0)
out=in1;
else
out=in2;
end
else
out=1'b0;
end
endmodule

module 8X1muxusingdecoder(in,sel,out);
input [7:0] in;
input [2:0] sel;
output out;
wire [3:0]w,o;
decoder d1(sel[2],sel[1],w);
mux m1(w[0],in[0],in[1],sel[0],o[0]);
mux m2(w[1],in[2],in[3],sel[0],o[1]);
mux m3(w[2],in[4],in[5],sel[0],o[2]);
mux m4(w[3],in[6],in[7],sel[0],o[3]);
or(out,o[0],o[1],o[2],o[3]);
endmodule
module tb;
reg [7:0] in;
reg [2:0] sel;
wire out;
practice dut(in,sel,out);
initial
begin
sel=3'b000;
in=8'b00000001;
#10
sel=3'b001;
in=8'b00101001;
#10
sel=3'b111;
in=8'b10000000;
#10
sel=3'b101;
in=8'b00100000;
end
endmodule
9) 1X8 demux using 1X4 demux and 1X2 demux

module demux1X2(in,sel,out);
input in,sel;
output reg [1:0]out;
always @(in,sel)
begin
if (sel==1'b0)
begin
out[0]=in;
out[1]=1'b0;
end
else
begin
out[1]=in;
out[0]=1'b0;
end
end
endmodule

module demux1X4(in,sel,out);
input in;
input [1:0] sel;
output reg [3:0] out;
always @(in,sel)
begin
if (sel==2'b00)
begin
out[0]=in;
out[1]=1'b0;
out[2]=1'b0;
out[3]=1'b0;
end
else if (sel==2'b01)
begin
out[0]=1'b0;
out[1]=in;
out[2]=1'b0;
out[3]=1'b0;
end
else if (sel==2'b10)
begin
out[0]=1'b0;
out[1]=1'b0;
out[2]=in;
out[3]=1'b0;
end
else
begin
out[0]=1'b0;
out[1]=1'b0;
out[2]=1'b0;
out[3]=in;
end
end
endmodule

module demux1X8(in,sel,out);
input in;
input [2:0]sel;
output [7:0]out;
wire [1:0]w;
demux1X2 d1(in,sel[2],w);
demux1X4 d2U(w[1],sel[1:0],out[7:4]);
demux1X4 d3L(w[0],sel[1:0],out[3:0]);
endmodule

module tb;
reg in;
reg [2:0] sel;
wire [7:0] out;
practice dut(in,sel,out);
initial
begin
in=1'b1;
sel=3'b000;
#5
in=1'b1;
sel=3'b001;
#5
in=1'b1;
sel=3'b010;
#5
in=1'b1;
sel=3'b011;
#5
in=1'b1;
sel=3'b100;
#5
in=1'b1;
sel=3'b101;
#5
in=1'b1;
sel=3'b110;
#5
in=1'b1;
sel=3'b111;
end
endmodule
10) 2X4 decoder and two mux and one xor gate
module decoder2X4(a,b,out);
input a,b;
output reg [3:0] out;
always @(a,b)
begin
case({a,b})
2'b00 : out=4'b0001;
2'b01 : out=4'b0010;
2'b10 : out=4'b0100;
2'b11 : out=4'b1000;
endcase
end
endmodule
module mux2X1(a,b,sel,out);
input a,b,sel;
output reg out;
always @(a,b,sel)
begin
if (sel==1'b0)
out=a;
else
out=b;
end
endmodule


module somerandomcircuit(a,b,c,d,out);
input a,b,c,d;
output out;
wire [3:0]w;
wire w1,w2;
decoder2X4 d1(a,b,w);
mux2X1 U(w[3],w[2],c,w1);
mux2X1 D(w[1],w[0],d,w2);
xor(out,w1,w2);
endmodule

module tb;
reg a,b,c,d;
reg check;
wire out;
practice dut(a,b,c,d,out);
initial
begin
a=1'b0;
b=1'b0;
c=1'b0;
d=1'b0;
#0.5
if ( out==(((a)&(~b)&(~d))|((a)&(b)&(d))|((a)&(~b)&(~c))|((~a)&(b)&(c))))
check=1'b1;
else
check=1'b0;
end

endmodule
11) 4 bit SISO shift register
module SISO4bit(in,clk,out);
input in,clk;
output reg out;
reg [2:0]q;
always @(posedge clk)
begin
q[2]<=in;
q[1]<=q[2];
q[0]<=q[1];
out<=q[0];
end

endmodule
module tb;
reg in,clk;
wire out;
practice dut(in,clk,out);
initial
begin
clk=1'b0;
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
end
always #5 clk=~clk;
endmodule

12) 4 bit SIPO shift register

module SIPO4bit(in,clk,out3,out2,out1,out0);
input in,clk;
output reg out3,out2,out1,out0;
always @(posedge clk)
begin
out3<=in;
out2<=out3;
out1<=out2;
out0<=out1;

end
endmodule
module tb;
reg clk,in;
wire out3,out2,out1,out0;
practice dut(in,clk,out3,out2,out1,out0);
initial
begin
clk=1'b0;
in=0;
#40
in=1'b1;
#10
in=1'b1;
#10;
in=1'b0;
#10
in=1'b1;
#10
$stop();
end
always #5 clk=!clk;
endmodule
13) 4 bit PISO shift register
 module piso(in,clk,reset,out);
input [3:0]in;
input clk,reset;
output reg out;
reg [2:0] q;
always @(posedge clk)
begin
if (reset)
begin
q[2]<=in[3];
q[1]<=in[2];
q[0]<=in[1];
out<=in[0];
end
else
begin
q[2]<=1'bx;
q[1]<=q[2];
q[0]<=q[1];
out<=q[0];
end
end
endmodule
module tb;
reg [3:0] in;
reg clk,reset;
wire out;
practice dut(in,clk,reset,out);
initial
begin
clk=1'b0;
reset=1'b1;
in=4'b1001;
#6
reset=1'b0;
end
always #5 clk=~clk;
endmodule

14) 4 bit PIPO shift register

module practice(clk,rst,in,out);
input clk,rst;
input [3:0] in;
output reg [3:0] out;
always @(posedge clk)
begin
if(rst)
begin
out[3]<=in[3];
out[2]<=in[2];
out[1]<=in[1];
out[0]<=in[0];
end
else
begin
out[3]<=1'b0;
out[2]<=out[3];
out[1]<=out[2];
out[0]<=out[1];
end
end
endmodule

module tb;
reg clk,rst;
reg [3:0] in;
wire [3:0] out;
practice dut(clk,rst,in,out);
initial
begin
clk=1'b0;
rst=1'b1;
in=4'b1101;
#6
rst=1'b0;
end
always #5 clk=~clk;
endmodule
15) 4 bit asynchronous Simultaneous “Up” and “Down” Counter
module jkf(j,k,clk,out,outbar,rst);
input j,k,clk,rst;
output reg out,outbar;
wire w1,w2,w3,w4;
always @(posedge clk)
begin
if(rst==1'b1)
begin
out<=1'b0;
outbar<=1'b1;
end
else if(j==1'b0 && k==1'b1)
begin
out<=1'b0;
outbar<=1'b1;
end
else if(j==1'b1 && k==1'b0)
begin
out<=1'b1;
outbar<=1'b0;
end
else if(j==1'b1 && k==1'b1)
begin
out<=~out;
outbar<=~outbar;
end
else
begin
out<=out;
outbar<=outbar;
end

end
endmodule


module asyncountre(clk,rst,outup,outdown);
input clk,rst;
output [3:0] outup,outdown;
jkf d1(1'b1,1'b1,clk,outup[0],outdown[0],rst);
jkf d2(1'b1,1'b1,outdown[0],outup[1],outdown[1],rst);
jkf d3(1'b1,1'b1,outdown[1],outup[2],outdown[2],rst);
jkf d4(1'b1,1'b1,outdown[2],outup[3],outdown[3],rst);

endmodule

module tb;
reg clk,rst;
wire [3:0] outup,outdown;
practice dut(clk,rst,outup,outdown);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
end
always #5 clk=~clk;
endmodule

16) MOD 10 Asynchronous counter 
The below code work fine on simulator(eda playground but not in quartus prime)

module asycounter10(clk,out,rst);
input clk,rst;
output reg [3:0] out;
wire w;
always @(negedge clk or posedge w)
begin
if(rst==1'b1 || w==1'b1 )
out[0]<=1'b0;
else
out[0]<=~out[0];
end
always @(negedge out[0] or posedge w)
begin
if(rst==1'b1 || w==1'b1)
out[1]<=1'b0;
else
out[1]<=~out[1];
end
always @(negedge out[1] or posedge w )
begin
if(rst==1'b1 || w==1'b1)
out[2]<=1'b0;
else
out[2]<=~out[2];
end
always @(negedge out[2] or posedge w )
begin
if(rst==1'b1 || w==1'b1)
out[3]<=1'b0;
else
out[3]<=~out[3];
end
assign  #1 w=out[3]&out[1];//provide delay for correct operation
endmodule

module tb;
reg clk,rst;
wire [3:0] out;
asycounter10 dut(clk,out,rst);
initial
begin
clk=1'b0;
rst=1'b0;
#11
rst=1'b1;
#22
rst=1'b0;
end
always #5 clk=~clk;
endmodule

17) Dual Edge Triggered Flip Flop

module DDFF(in,out,clk,rst);
input in,clk,rst;
output reg out;
reg q1,q2;
always @(posedge clk)
begin
if (rst)
q1<=0;
else
q1<=in;
end
always @(negedge clk)
begin
if (rst)
q2<=0;
else
q2<=in;
end
always @(q1,q2,clk)
begin
if (clk==1'b1)
out=q1;
else
out=q2;
end
endmodule

module tb;
reg in,clk,rst;
wire out;
DDFF dut(in,out,clk,rst);
initial
begin
clk=1'b0;
rst=1'b1;
in=1'b1;
#11
rst=1'b0;
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
end
always #5 clk=~clk;
endmodule

18) Design synchronous counter for the 3-7-0-6-4-1 sequence using D Flip Flop

module syncounter(clk,rst,q);
input clk,rst;
output reg [3:1] q;
always @(posedge clk)
begin
if(rst)
q<=3'b011;
else
begin
q[3]<=((~q[3])&q[2])|(q[2]&(~q[1]))|((~q[3])&(~q[1]));
q[2]<=~q[3];
q[1]<=((~q[3])&q[1])|(q[3]&(~q[2]));
end
end
endmodule
module tb;
reg clk,rst;
wire [3:1] q;
syncounter dut(clk,rst,q);
initial
begin
clk=1'b0;
rst=1'b1;
#7
rst=1'b0;
end
always # 5 clk=~clk;
endmodule

19) 4bit johnson counter

module DFF(clk,rst,in,out,outbar);
input clk,rst,in;
output reg out,outbar;
always @(posedge clk)
begin
if(rst)
begin
out<=1'b0;
outbar<=1'b1;
end
else
begin
out<=in;
outbar<=~in;
end
end
endmodule
module johncounter(clk,rst,out,outbar);
input clk,rst;
output [3:0] out,outbar;
DFF d3(clk,rst,outbar[0],out[3],outbar[3]);
DFF d2(clk,rst,out[3],out[2],outbar[2]);
DFF d1(clk,rst,out[2],out[1],outbar[1]);
DFF d0(clk,rst,out[1],out[0],outbar[0]);
endmodule

module tb;
reg clk,rst;
wire [3:0] out,outbar;
johncounter dut(clk,rst,out,outbar);
initial
begin
clk=1'b0;
rst=1'b1;
#7
rst=1'b0;
end
always #5 clk=~clk;
endmodule

20) 4 bit LFSR circuit
(https://inst.eecs.berkeley.edu/~cs150/sp03/handouts/15/LectureA/lec27-2up.pdf in this website page 1 you can refe
diagram and output)

module LFSR(clk,rst,q);
input clk,rst;
output reg [3:0] q;
always @(posedge clk)
begin
if(rst)
begin
q[3]<=1'b0;
q[2]<=1'b0;
q[1]<=1'b0;
q[0]<=1'b1;
end
else
begin
q[0]<=q[3];
q[1]<=q[3]^q[0];
q[2]<=q[1];
q[3]<=q[2];
end
end
endmodule

module tb;
reg clk,rst;
wire [3:0] q;
practice LFSR(clk,rst,q);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
end
always # 5 clk=~clk;
endmodule

21) 11011 FSM overlapping Morre machine
 module fsm(clk,rst,in,out);
input clk,rst,in;
output reg out;
parameter A=3'b000,B=3'b001,C=3'b010,D=3'b100,E=3'b111,F=3'b110;
reg [2:0] ps,ns;
always @(posedge clk)
begin
if(rst)
ps<=A;
else
ps<=ns;
end
always @(ps,in)
begin
case(ps)
A : begin
ns=in?B:A;
out=1'b0;
end
B : begin
ns=in?C:A;
out=1'b0;
end
C : begin
ns=in?C:D;
out=1'b0;
end
D : begin
ns=in?E:A;
out=1'b0;
end
E : begin
ns=in?F:A;
out=1'b0;
end
F : begin
ns=in?C:D;
out=1'b1;
end
endcase
end
endmodule

module tb;
reg clk,rst,in;
wire out;
fsm dut(clk,rst,in,out);
initial
begin
clk=1'b0;
rst=1'b1;
in=1'b1;
#6
rst=1'b0;
#19
in=1'b1;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b1;
#10;
in=1'b0;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10;
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b1;
end
always #5 clk=~clk;
endmodule

22) 101010  overlapping FSM mealy machine 

module mealy(clk,rst,in,out);
input clk,rst,in;
output reg out;
parameter A=4'b0000,B=4'b0001,C=4'b0010,D=4'b0100,E=4'b1000,F=4'b1100;
reg [3:0] ps,ns;
always @(posedge clk)
begin
if(rst)
ps<=A;
else
ps<=ns;
end

always @(ps,in)
begin
case(ps)
A: begin
ns=in?B:A;
out=1'b0;
end
B: begin
ns=in?B:C;
out=1'b0;
end
C: begin
ns=in?D:A;
out=1'b0;
end
D: begin
ns=in?B:E;
out=1'b0;
end
E: begin
ns=in?F:A;
out=1'b0;
end
F: begin
ns=in?B:E;
out=in?1'b0:1'b1;
end
endcase
end
endmodule

module tb;
reg clk,rst,in;
wire out;
mealy dut(clk,rst,in,out);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
#9
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
end
always #5 clk=~clk;
endmodule

23) 1001 & 010 overlapping mealy FSM

module mealy(clk,rst,in,out);
input clk,rst,in;
output reg out;
parameter S0=4'b0000,S1=4'b0001,S2=4'b0010,S3=4'b0100,S4=4'b1000,S5=4'b1100;
reg [3:0] ns,ps;
always @(posedge clk)
begin
if(rst)
ps<=S0;
else
ps<=ns;
end

always @(ps,in)
begin
case(ps)
S0: begin
ns=in?S1:S4;
out=1'b0;
end
S1: begin
ns=in?S1:S2;
out=1'b0;
end
S2: begin
ns=in?S5:S3;
out=1'b0;
end
S3: begin
ns=in?S5:S4;
out=in?1'b1:1'b0;
end
S4: begin
ns=in?S5:S4;
out=1'b0;
end
S5: begin
ns=in?S1:S2;
out=in?1'b0:1'b1;
end
endcase
end
endmodule

module tb;
reg clk,rst,in;
wire out;
mealy dut(clk,rst,in,out);
initial
begin
clk=1'b0;
rst=1'b1;
in=1'b1;
#6
rst=1'b0;
#9
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
end
always #5 clk=~clk;
endmodule

24) 2's complement of a binary number using Moore FSM

module (clk,rst,in,out);
input clk,rst,in;
output reg out;
parameter A=2'b00,B=2'b01,C=2'b10;
reg [1:0] ps,ns;
always @(posedge clk)
begin
if(rst)
ps<=A;
else
ps<=ns;
end

always @(ps,in)
begin
case(ps)
A : begin
ns=in?B:A;
out=1'b0;
end
B : begin
ns=in?C:B;
out=1'b1;
end
C : begin
ns=in?C:B;
out=1'b0;
end
endcase
end
endmodule

module tb;
reg clk,rst,in;
wire out;
complement dut(clk,rst,in,out);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
#9
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
end
always #5 clk=~clk;
endmodule

25) Vending machine using mealy machine with change
In this, we will get drink bottle when price = 15 , and we have only 5 and 10 avialable

module machine(clk,rst,coin,bottlereceived,change);
input clk,rst;
input [3:0] coin;
output reg bottlereceived;
output reg [3:0] change;
parameter S0=2'b00,S1=2'b01,S2=2'b10;
reg [1:0] ps,ns;

always @(posedge clk)
begin
if(rst)
ps<=S0;
else
ps<=ns;
end

always @(ps,coin)
begin
case(ps)
S0 : begin
ns = (coin==4'b0101) ? S1 : ((coin==4'b1010) ? S2:S0);
bottlereceived = 1'b0;
change = 4'b0000;
end
S1 : begin
ns = (coin==4'b0101) ? S2 : S0;
bottlereceived = (coin==4'b1010) ? 1'b1 : 1'b0;
change = (coin==4'b0000) ? 4'b0101 : 4'b0000;
end
S2 : begin
ns = S0;
bottlereceived = (coin==4'b0101 || coin==4'b1010) ? 1'b1 : 1'b0;
change = (coin==4'b1010)? 4'b0101 : ((coin==4'b0000) ? 4'b1010 : 4'b0000);
end
endcase
end
endmodule

module tb;
reg clk,rst;
reg [3:0] coin;
wire bottlereceived;
wire [3:0] change;
machine dut(clk,rst,coin,bottlereceived,change);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
#9
coin=4'b0101;
#10;
coin=4'b0101;
#10;
coin=4'b0101;
#10;
coin=4'b0101;
#10;
coin=4'b1010;
#10;
coin=4'b1010;
#10;
coin=4'b0101;
#10;
coin=4'b1010;
#10;
coin=4'b1010;
#10;
coin=4'b1010;
#10;
coin=4'b0000;
end
always #5 clk=~clk;
endmodule

26) single port SRAM with Synchronous read/write

module sram(clk,datain,dataout,enablewrite,readaddress,writeaddress);
input clk,enablewrite;
input [7:0] datain;
input [5:0] readaddress,writeaddress;
output reg [7:0] dataout;
reg [7:0] ram [63:0];

always @(posedge clk)
begin
if(enablewrite)
ram[writeaddress]<=datain;
dataout<=ram[readaddress];
end
endmodule

module tb;
reg clk,enablewrite;
reg [5:0] readaddress,writeaddress;
reg [7:0] datain;
wire [7:0] dataout;
sram dut(clk,datain,dataout,enablewrite,readaddress,writeaddress);
initial
begin
clk=1'b0;
enablewrite=1'b0;
datain=8'b00000000;
#12
enablewrite=1'b1;
datain=8'b11110000;
writeaddress=6'b000000;
readaddress=6'b000000;
#10
datain=8'b11111111;
writeaddress=6'b000000;
readaddress=6'b000000;

end
initial
begin
#30
$finish();
end
always #5 clk=~clk;
endmodule

27) Synchronous FIFO

module fifo(clk,rst,wen,ren,data,dataout,full,empty);
input clk,rst,wen,ren;
input [7:0] data;
output reg [7:0] dataout;
output full,empty;
reg [7:0] memory [15:0];
reg [3:0] wrptr,rdptr;
integer i;
always @(posedge clk)
begin
if (rst)
begin
for(i=0;i<16;i=i+1)
memory[i]=8'b00000000;
wrptr<=4'b0000;
dataout<=8'b00000000;
rdptr<=4'b0000;
end
// write
else if (wen==1'b1)
begin
if (wrptr <  4'b1111)
begin
memory[wrptr]<=data;
wrptr<=wrptr+1'b1;
end
else if(wrptr==4'b1111)
begin
memory[wrptr]<=data;
end
end

//read
else if(ren==1'b1)
begin
if(rdptr!=wrptr)
begin
dataout<=memory[rdptr];
memory[rdptr]<=8'b00000000;
rdptr<=rdptr+1'b1;
end
else if(rdptr==wrptr)
begin
dataout<=memory[rdptr];
memory[rdptr]<=8'b00000000;
wrptr<=4'b0000;
rdptr<=4'b0000;
end
end
end
assign empty=(rdptr==wrptr)?1'b1:1'b0;
assign full=(wrptr==4'b1111)?1'b1:1'b0;
endmodule

module tb;
reg clk,rst,wen,ren;
reg [7:0] data;
wire [7:0] dataout;
wire full,empty;
fifo dut(clk,rst,wen,ren,data,dataout,full,empty);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
wen=1'b1;
#9
data=8'b01010101;
#10;
data=8'b10101010;
#10;
data=8'b00001111;
#10;
data=8'b11110000;
#10;
data=8'b00110011;
#10;
data=8'b11001100;
#10;
data=8'b11100011;
#10;
data=8'b00011100;
#5;
wen=1'b0;
#5
ren=1'b1;
end
always #5 clk=~clk;
endmodule

28) Generate output = 1 for 4 clock cycle and for next 4 clock cycle output = 0. Repeat this sequence for forever

module clk4(clk,rst,out);
input clk,rst;
output reg out;
reg [3:0] pose,nege;
always @(posedge clk)
begin
if (rst)
begin
pose=4'b0000;
nege=4'b0000;
out=1'b0;
end
else
begin
if((pose<4'b0100) && ((nege==4'b0000) || (nege>=4'b0100)))
begin
out=1'b1;
pose=pose+1'b1;
nege=4'b0000;
end
else if (pose >= 4'b0100)
begin
out=1'b0;
nege=nege+1'b1;
pose=4'b0000;
end
else if (nege < 4'b0100)
begin
out=1'b0;
nege=nege+1'b1;
pose=4'b0000;
end
end
end
endmodule

module tb;
reg clk,rst;
wire out;
clk4 dut(clk,rst,out);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
end
always # 5 clk=~clk;
endmodule

29) Moore FSM gives output 1 when detects even number of ones recived else output is 0

module even(clk,rst,in,out);
input clk,rst,in;
output reg out;
parameter S0=3'b100,S1=3'b010,S2=3'b001;
reg [2:0] ps,ns;
always @(posedge clk)
begin
if(rst)
ps<=S0;
else
ps<=ns;
end

always @(ps,in)
begin
case(ps)
S0 : begin
ns=in?S1:S0;
out=1'b0;
end
S1 : begin
ns=in?S2:S1;
out=1'b0;
end
S2 : begin
ns=in?S1:S0;
out=1'b1;
end
endcase
end
endmodule

module tb;
reg clk,rst,in;
wire out;
even dut(clk,rst,in,out);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
#9
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b1;
end
always #5 clk=~clk;
endmodule

30) Design a synchronous Traffic light controller cicuit

module trafficlight(clk,rst,red,green,yellow);
input clk,rst;
output  red,green,yellow;
parameter GREEN = 3'b000 ,YELLOW = 3'b001 ,RED = 3'b010 ,REDYELLOW = 3'b100 ,WAITED = 3'b111;
reg [2:0] ps,ns;
reg [5:0] count;

always @(posedge clk)
begin
if(rst)
ps <= GREEN;
else
ps <= ns;
end

always @(ps,count)
begin
case(ps)
GREEN : ns = (count == 6'b001111) ? YELLOW : GREEN;
YELLOW : ns = (count == 6'b010100) ? RED : YELLOW;
RED : ns = (count == 6'b011110) ? REDYELLOW : RED;
REDYELLOW : ns = (count == 6'b100011) ? WAITED : REDYELLOW;
WAITED : ns = GREEN;
endcase
end

always @(posedge clk)
begin
if(rst)
count <= 5'b000000;
else if (ps == WAITED)
count <= 5'b000000;
else
count <= count + 1'b1;
end

assign red = (ps == RED || ps == REDYELLOW) ? 1'b1 : 1'b0;
assign yellow = (ps == YELLOW || ps == REDYELLOW) ? 1'b1 : 1'b0;
assign green = (ps == GREEN) ? 1'b1 : 1'b0;
endmodule

module tb;
reg clk,rst;
wire red,green,yellow;
trafficlight dut(clk,rst,red,green,yellow);

initial
begin
clk = 1'b0;
rst = 1'b1;
#6
rst = 1'b0;

end
always #5 clk = ~clk;
endmodule

31) Lfsr5 ( https://hdlbits.01xz.net/wiki/Lfsr5)
module lfsr5(clk,reset,q);
    input clk,reset;
    output reg [4:0] q;
    always @(posedge clk)
        begin
            if(reset)
                q <= 5'h1;
            else
                begin
                    q[4] <= 1'b0^q[0];
                    q[3] <= q[4];
                    q[2] <= q[0]^q[3];
                    q[1] <= q[2];
                    q[0] <= q[1];
                end
        end
endmodule



















































