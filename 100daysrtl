1) 3 to 8 decoder
   module practice(in,out);
input [2:0] in;
output [7:0] out;
reg [7:0]out;
always @(*)
begin
case (in)
3'b000: out=8'b00000001;
3'b001: out=8'b00000010;
3'b010: out=8'b00000100;
3'b011: out=8'b00001000;
3'b100: out=8'b00010000;
3'b101: out=8'b00100000;
3'b110: out=8'b01000000;
3'b111: out=8'b10000000;
default : out=8'b00000000;

endcase

end

endmodule
module test;
reg [2:0]in;
wire [7:0]out;
integer i;
practice dut(in,out);
initial
begin
for (i=0;i<8;i=i+1)
begin
in=i;
#10;
end
end
endmodule
2) 8 bit graycounter 
module graycounteightbit(clk,out,rst);
input clk,rst;
output reg [2:0] out;
reg [2:0]count;
always @(posedge clk)
begin
if (rst)
begin
count<=3'b000;
out<=3'b000;
end
else
begin
count<=count+1'b1;
out[2]<=count[2];
out[1]<=count[2]^count[1];
out[0]<=count[1]^count[0];
end
end
endmodule
module test;
reg clk,rst;
wire [2:0]out;
practice dut(clk,out,rst);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
end
always #5 clk=~clk;
endmodule
3) half adder using 4X1 mux
module mux4X1(in1,in2,in3,in4,sel1,sel2,out);
input in1,in2,in3,in4,sel1,sel2;
output reg out;
always @(*)
begin
if ({sel1,sel2}==2'b00)
out=in1;
else if ({sel1,sel2}==2'b01)
out=in2;
else if ({sel1,sel2}==2'b10)
out=in3;
else if ({sel1,sel2}==2'b11)
out=in4;
end
endmodule

module halfadderusingmux(x,y,sum,carry);
input x,y;
output sum,carry;
mux4X1 d1(0,1,1,0,x,y,sum);
mux4X1 d2(0,0,0,1,x,y,carry);
endmodule

module test;
reg x,y;
wire sum,carry;
practice dut(x,y,sum,carry);
initial
begin
x=1'b0;
y=1'b0;
#10
x=1'b0;
y=1'b1;
#10
x=1'b1;
y=1'b0;
#10
x=1'b1;
y=1'b1;
end
endmodule
4) 8 X 3 Priority Encoder
 module prioencder(in,out);
input [7:0]in;
output reg [2:0]out;
always @(*)
begin
casex(in)
8'b00000001 : out = 3'b000;
8'b0000001x : out = 3'b001;
8'b000001xx : out = 3'b010;
8'b00001xxx : out = 3'b011;
8'b0001xxxx : out = 3'b100;
8'b001xxxxx : out = 3'b101;
8'b01xxxxxx : out = 3'b110;
8'b1xxxxxxx : out = 3'b111;
default : out=3'bxxx;
endcase
end
endmodule
module test;
reg [7:0]in;
wire [2:0]out;
practice dut(in,out);
initial
begin
in=8'b11001100; #10;
in=8'b01100110; #10;
in=8'b00110011; #10;
in=8'b00010010; #10;
in=8'b00001001; #10;
in=8'b00000100; #10;
in=8'b00000011; #10;
in=8'b00000001; #10;
in=8'b00000000; # 10; 
end
endmodule
5) 8_bit_barrel_shifter
module mux2X1(in0,in1,out,sel);
input in0,in1,sel;
output out;
wire w1,w2,w3;
not(w1,sel);
and(w2,w1,in0);
and(w3,sel,in1);
or(out,w2,w3);
endmodule

module barrel8bitshifter(in,out,s);
input [7:0] in;
input [2:0] s;
output [7:0] out;
wire [15:0]w;
mux2X1 one(in[7],in[0],w[0],s[0]);
mux2X1 two(in[6],in[7],w[1],s[0]);
mux2X1 three(in[5],in[6],w[2],s[0]);
mux2X1 four(in[4],in[5],w[3],s[0]);
mux2X1 five(in[3],in[4],w[4],s[0]);
mux2X1 six(in[2],in[3],w[5],s[0]);
mux2X1 seven(in[1],in[2],w[6],s[0]);
mux2X1 eight(in[0],in[1],w[7],s[0]);

mux2X1 one1(w[0],w[6],w[8],s[1]);
mux2X1 two2(w[1],w[7],w[9],s[1]);
mux2X1 three3(w[2],w[0],w[10],s[1]);
mux2X1 four4(w[3],w[1],w[11],s[1]);
mux2X1 five5(w[4],w[2],w[12],s[1]);
mux2X1 six6(w[5],w[3],w[13],s[1]);
mux2X1 seven7(w[6],w[4],w[14],s[1]);
mux2X1 eight8(w[7],w[5],w[15],s[1]);

mux2X1 one11(w[8],w[12],out[7],s[2]);
mux2X1 two22(w[9],w[13],out[6],s[2]);
mux2X1 three33(w[10],w[14],out[5],s[2]);
mux2X1 four44(w[11],w[15],out[4],s[2]);
mux2X1 five55(w[12],w[8],out[3],s[2]);
mux2X1 six66(w[13],w[9],out[2],s[2]);
mux2X1 seven77(w[14],w[10],out[1],s[2]);
mux2X1 eight88(w[15],w[11],out[0],s[2]);


endmodule
module tb;
reg [7:0] in;
reg [2:0] s;
wire [7:0] out;
practice dut(in,out,s);
initial
begin
in=8'b00001111;
s=3'b000;
#10
in=8'b00001111;
s=3'b001;
#10
in=8'b00001111;
s=3'b010;
#10
in=8'b00001111;
s=3'b011;
#10
in=8'b00001111;
s=3'b100;
#10
in=8'b00001111;
s=3'b101;
#10
in=8'b00001111;
s=3'b110;
#10
in=8'b00001111;
s=3'b111;

end
endmodule
S0 S1 S2 input      output
0  0  0  00001111   00001111
0  0  1  00001111   10000111
0  1  0  00001111   11000011
0  1  1  00001111   11100001
1  0  0  00001111   11110000
1  0  1  00001111   01111000
1  1  0  00001111   00111100
1  1  1  00001111   00011110


