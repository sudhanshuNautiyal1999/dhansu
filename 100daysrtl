1) 3 to 8 decoder
module decoder3X8(in,out);
input [2:0] in;
output [7:0] out;
reg [7:0]out;
always @(*)
begin
case (in)
3'b000: out=8'b00000001;
3'b001: out=8'b00000010;
3'b010: out=8'b00000100;
3'b011: out=8'b00001000;
3'b100: out=8'b00010000;
3'b101: out=8'b00100000;
3'b110: out=8'b01000000;
3'b111: out=8'b10000000;
default : out=8'b00000000;

endcase

end

endmodule
module test;
reg [2:0]in;
wire [7:0]out;
integer i;
decoder3X8 dut(in,out);
initial
begin
for (i=0;i<8;i=i+1)
begin
in=i;
#10;
end
end
endmodule

2) 8 bit graycounter 

module graycounteightbit(clk,out,rst);
input clk,rst;
output reg [2:0] out;
reg [2:0]count;
always @(posedge clk)
begin
if (rst)
begin
count<=3'b000;
out<=3'b000;
end
else
begin
count<=count+1'b1;
out[2]<=count[2];
out[1]<=count[2]^count[1];
out[0]<=count[1]^count[0];
end
end
endmodule
module test;
reg clk,rst;
wire [2:0]out;
practice dut(clk,out,rst);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
end
always #5 clk=~clk;
endmodule

3) half adder using 4X1 mux

module mux4X1(in1,in2,in3,in4,sel1,sel2,out);
input in1,in2,in3,in4,sel1,sel2;
output reg out;
always @(*)
begin
if ({sel1,sel2}==2'b00)
out=in1;
else if ({sel1,sel2}==2'b01)
out=in2;
else if ({sel1,sel2}==2'b10)
out=in3;
else if ({sel1,sel2}==2'b11)
out=in4;
end
endmodule

module halfadderusingmux(x,y,sum,carry);
input x,y;
output sum,carry;
mux4X1 d1(0,1,1,0,x,y,sum);
mux4X1 d2(0,0,0,1,x,y,carry);
endmodule

module test;
reg x,y;
wire sum,carry;
practice dut(x,y,sum,carry);
initial
begin
x=1'b0;
y=1'b0;
#10
x=1'b0;
y=1'b1;
#10
x=1'b1;
y=1'b0;
#10
x=1'b1;
y=1'b1;
end
endmodule

4) 8 X 3 Priority Encoder

 module prioencder(in,out);
input [7:0]in;
output reg [2:0]out;
always @(*)
begin
casex(in)
8'b00000001 : out = 3'b000;
8'b0000001x : out = 3'b001;
8'b000001xx : out = 3'b010;
8'b00001xxx : out = 3'b011;
8'b0001xxxx : out = 3'b100;
8'b001xxxxx : out = 3'b101;
8'b01xxxxxx : out = 3'b110;
8'b1xxxxxxx : out = 3'b111;
default : out=3'bxxx;
endcase
end
endmodule
module test;
reg [7:0]in;
wire [2:0]out;
practice dut(in,out);
initial
begin
in=8'b11001100; #10;
in=8'b01100110; #10;
in=8'b00110011; #10;
in=8'b00010010; #10;
in=8'b00001001; #10;
in=8'b00000100; #10;
in=8'b00000011; #10;
in=8'b00000001; #10;
in=8'b00000000; # 10; 
end
endmodule

5) 8_bit_barrel_shifter

module mux2X1(in0,in1,out,sel);
input in0,in1,sel;
output out;
wire w1,w2,w3;
not(w1,sel);
and(w2,w1,in0);
and(w3,sel,in1);
or(out,w2,w3);
endmodule

module barrel8bitshifter(in,out,s);
input [7:0] in;
input [2:0] s;
output [7:0] out;
wire [15:0]w;
mux2X1 one(in[7],in[0],w[0],s[0]);
mux2X1 two(in[6],in[7],w[1],s[0]);
mux2X1 three(in[5],in[6],w[2],s[0]);
mux2X1 four(in[4],in[5],w[3],s[0]);
mux2X1 five(in[3],in[4],w[4],s[0]);
mux2X1 six(in[2],in[3],w[5],s[0]);
mux2X1 seven(in[1],in[2],w[6],s[0]);
mux2X1 eight(in[0],in[1],w[7],s[0]);

mux2X1 one1(w[0],w[6],w[8],s[1]);
mux2X1 two2(w[1],w[7],w[9],s[1]);
mux2X1 three3(w[2],w[0],w[10],s[1]);
mux2X1 four4(w[3],w[1],w[11],s[1]);
mux2X1 five5(w[4],w[2],w[12],s[1]);
mux2X1 six6(w[5],w[3],w[13],s[1]);
mux2X1 seven7(w[6],w[4],w[14],s[1]);
mux2X1 eight8(w[7],w[5],w[15],s[1]);

mux2X1 one11(w[8],w[12],out[7],s[2]);
mux2X1 two22(w[9],w[13],out[6],s[2]);
mux2X1 three33(w[10],w[14],out[5],s[2]);
mux2X1 four44(w[11],w[15],out[4],s[2]);
mux2X1 five55(w[12],w[8],out[3],s[2]);
mux2X1 six66(w[13],w[9],out[2],s[2]);
mux2X1 seven77(w[14],w[10],out[1],s[2]);
mux2X1 eight88(w[15],w[11],out[0],s[2]);


endmodule
module tb;
reg [7:0] in;
reg [2:0] s;
wire [7:0] out;
practice dut(in,out,s);
initial
begin
in=8'b00001111;
s=3'b000;
#10
in=8'b00001111;
s=3'b001;
#10
in=8'b00001111;
s=3'b010;
#10
in=8'b00001111;
s=3'b011;
#10
in=8'b00001111;
s=3'b100;
#10
in=8'b00001111;
s=3'b101;
#10
in=8'b00001111;
s=3'b110;
#10
in=8'b00001111;
s=3'b111;

end
endmodule
S0 S1 S2 input      output
0  0  0  00001111   00001111
0  0  1  00001111   10000111
0  1  0  00001111   11000011
0  1  1  00001111   11100001
1  0  0  00001111   11110000
1  0  1  00001111   01111000
1  1  0  00001111   00111100
1  1  1  00001111   00011110

6) 4*4 muliplier

module Halfadder(a,b,s,c);
input a,b;
output s,c;
xor(s,a,b);
and(c,a,b);
endmodule

module Fulladder(a,b,cin,sum,cout);
input a,b,cin;
output sum,cout;
wire w1,w2,w3;
Halfadder HA1(a,b,w1,w2);
Halfadder HA2(w1,cin,sum,w3);
or(cout,w2,w3);
endmodule

module multiplier4X4(a,b,out);
input [3:0] a,b;
output [7:0] out;
wire [32:0] w;
and(out[0],a[0],b[0]);
and(w[1],a[1],b[0]);
and(w[2],a[0],b[1]);
and(w[3],a[1],b[1]);
and(w[4],a[2],b[0]);
and(w[5],a[2],b[1]);
and(w[6],a[3],b[0]);
and(w[12],a[0],b[2]);
and(w[14],a[1],b[2]);
and(w[17],a[3],b[1]);
and(w[20],a[0],b[3]);
and(w[22],a[2],b[2]);
and(w[25],a[3],b[2]);
and(w[28],a[1],b[3]);
and(w[30],a[2],b[3]);
and(w[32],a[3],b[3]);
Halfadder HA3(w[1],w[2],out[1],w[7]);
Fulladder FA1(w[3],w[4],w[7],w[8] ,w[9]);
Fulladder FA2(w[5],w[6],w[9],w[10],w[11]);
Halfadder HA4(w[12],w[8],out[2],w[13]);
Fulladder FA3(w[14],w[10],w[13],w[15],w[16]);
Fulladder FA4(w[17],w[11],w[16],w[18],w[19]);
Halfadder HA5(w[20],w[15],out[3],w[21]);
Fulladder FA5(w[22],w[21],w[18],w[23],w[24]);
Fulladder FA6(w[25],w[24],w[19],w[26],w[27]);
Halfadder HA6(w[28],w[23],out[4],w[29]);
Fulladder FA7(w[30],w[29],w[26],out[5],w[31]);
Fulladder FA8(w[32],w[31],w[27],out[6],out[7]);
endmodule
module test;
reg [3:0] a,b;
wire [7:0] out;
practice dut(a,b,out);
initial
begin
a=4'b1000;
b=4'b1000;
#10
a=4'b1010;
b=4'b0011;
#10
a=4'b0001;
b=4'b0001;
#10
a=4'b0001;
b=4'b0000;
#10
a=4'b1101;
b=4'b0011;
#10
a=4'b1111;
b=4'b1111;
#10
a=4'b0000;
b=4'b0000;
#10
a=4'b1001;
b=4'b1001;

end
endmodule

7) 4 bit carry select adder

module Fulladder(a,b,cin,sum,cout);
input a,b,cin;
output sum,cout;
wire [2:0] w;
xor(w[0],a,b);
xor(sum,w[0],cin);
and(w[1],w[0],cin);
and(w[2],a,b);
or(cout,w[1],w[2]);
endmodule

module mux2X1(in1,in2,sel,out);
input in1,in2,sel;
output out;
wire [2:0]w;
not(w[0],sel);
and(w[1],in2,sel);
and(w[2],in1,w[0]);
or(out,w[1],w[2]);
endmodule
module carryselectadder(a,b,sum,cout);
input [3:0]a,b;
output cout;
output [3:0]sum;
wire [15:0] w;
Fulladder FA1(a[0],b[0],1'b0,w[0],w[1]);
Fulladder FA2(a[1],b[1],w[1],w[2],w[3]);
Fulladder FA3(a[2],b[2],w[3],w[4],w[5]);
Fulladder FA4(a[3],b[3],w[5],w[6],w[13]);

Fulladder FA5(a[0],b[0],1'b1,w[7],w[8]);
Fulladder FA6(a[1],b[1],w[8],w[9],w[10]);
Fulladder FA7(a[2],b[2],w[10],w[11],w[12]);
Fulladder FA8(a[3],b[3],w[12],w[14],w[15]);

mux2X1 MUX1(w[0],w[7],1'b0,sum[0]);
mux2X1 MUX2(w[2],w[9],1'b0,sum[1]);
mux2X1 MUX3(w[4],w[11],1'b0,sum[2]);
mux2X1 MUX4(w[6],w[14],1'b0,sum[3]);
mux2X1 MUX5(w[13],w[15],1'b0,cout);
endmodule

module tb;
reg [3:0]a,b;
wire cout;
wire [3:0] sum;
carryselectadder dut(a,b,sum,cout);
initial
begin
a=4'b1010;
b=4'b0001;
end
endmodule

8) 8X1 mux using 2:4 decoder

module decoder(in1,in2,q);
input in1,in2;
output reg [3:0]q;
always @(in1,in2)
begin
case({in1,in2})
2'b00 : q=4'b0001;
2'b01 : q=4'b0010;
2'b10 : q=4'b0100;
2'b11 : q=4'b1000;
endcase
end
endmodule

module mux(enable,in1,in2,sel,out);
input enable,in1,in2,sel;
output reg out;
always @(enable,in1,in2,sel)
begin
if (enable)
begin
if (sel==1'b0)
out=in1;
else
out=in2;
end
else
out=1'b0;
end
endmodule

module 8X1muxusingdecoder(in,sel,out);
input [7:0] in;
input [2:0] sel;
output out;
wire [3:0]w,o;
decoder d1(sel[2],sel[1],w);
mux m1(w[0],in[0],in[1],sel[0],o[0]);
mux m2(w[1],in[2],in[3],sel[0],o[1]);
mux m3(w[2],in[4],in[5],sel[0],o[2]);
mux m4(w[3],in[6],in[7],sel[0],o[3]);
or(out,o[0],o[1],o[2],o[3]);
endmodule
module tb;
reg [7:0] in;
reg [2:0] sel;
wire out;
practice dut(in,sel,out);
initial
begin
sel=3'b000;
in=8'b00000001;
#10
sel=3'b001;
in=8'b00101001;
#10
sel=3'b111;
in=8'b10000000;
#10
sel=3'b101;
in=8'b00100000;
end
endmodule

9) 1X8 demux using 1X4 demux and 1X2 demux

module demux1X2(in,sel,out);
input in,sel;
output reg [1:0]out;
always @(in,sel)
begin
if (sel==1'b0)
begin
out[0]=in;
out[1]=1'b0;
end
else
begin
out[1]=in;
out[0]=1'b0;
end
end
endmodule

module demux1X4(in,sel,out);
input in;
input [1:0] sel;
output reg [3:0] out;
always @(in,sel)
begin
if (sel==2'b00)
begin
out[0]=in;
out[1]=1'b0;
out[2]=1'b0;
out[3]=1'b0;
end
else if (sel==2'b01)
begin
out[0]=1'b0;
out[1]=in;
out[2]=1'b0;
out[3]=1'b0;
end
else if (sel==2'b10)
begin
out[0]=1'b0;
out[1]=1'b0;
out[2]=in;
out[3]=1'b0;
end
else
begin
out[0]=1'b0;
out[1]=1'b0;
out[2]=1'b0;
out[3]=in;
end
end
endmodule

module demux1X8(in,sel,out);
input in;
input [2:0]sel;
output [7:0]out;
wire [1:0]w;
demux1X2 d1(in,sel[2],w);
demux1X4 d2U(w[1],sel[1:0],out[7:4]);
demux1X4 d3L(w[0],sel[1:0],out[3:0]);
endmodule

module tb;
reg in;
reg [2:0] sel;
wire [7:0] out;
practice dut(in,sel,out);
initial
begin
in=1'b1;
sel=3'b000;
#5
in=1'b1;
sel=3'b001;
#5
in=1'b1;
sel=3'b010;
#5
in=1'b1;
sel=3'b011;
#5
in=1'b1;
sel=3'b100;
#5
in=1'b1;
sel=3'b101;
#5
in=1'b1;
sel=3'b110;
#5
in=1'b1;
sel=3'b111;
end
endmodule

10) 2X4 decoder and two mux and one xor gate

module decoder2X4(a,b,out);
input a,b;
output reg [3:0] out;
always @(a,b)
begin
case({a,b})
2'b00 : out=4'b0001;
2'b01 : out=4'b0010;
2'b10 : out=4'b0100;
2'b11 : out=4'b1000;
endcase
end
endmodule
module mux2X1(a,b,sel,out);
input a,b,sel;
output reg out;
always @(a,b,sel)
begin
if (sel==1'b0)
out=a;
else
out=b;
end
endmodule


module somerandomcircuit(a,b,c,d,out);
input a,b,c,d;
output out;
wire [3:0]w;
wire w1,w2;
decoder2X4 d1(a,b,w);
mux2X1 U(w[3],w[2],c,w1);
mux2X1 D(w[1],w[0],d,w2);
xor(out,w1,w2);
endmodule

module tb;
reg a,b,c,d;
reg check;
wire out;
practice dut(a,b,c,d,out);
initial
begin
a=1'b0;
b=1'b0;
c=1'b0;
d=1'b0;
#0.5
if ( out==(((a)&(~b)&(~d))|((a)&(b)&(d))|((a)&(~b)&(~c))|((~a)&(b)&(c))))
check=1'b1;
else
check=1'b0;
end

endmodule

11) 4 bit SISO shift register

module SISO4bit(in,clk,out);
input in,clk;
output reg out;
reg [2:0]q;
always @(posedge clk)
begin
q[2]<=in;
q[1]<=q[2];
q[0]<=q[1];
out<=q[0];
end

endmodule
module tb;
reg in,clk;
wire out;
practice dut(in,clk,out);
initial
begin
clk=1'b0;
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
end
always #5 clk=~clk;
endmodule

12) 4 bit SIPO shift register

module SIPO4bit(in,clk,out3,out2,out1,out0);
input in,clk;
output reg out3,out2,out1,out0;
always @(posedge clk)
begin
out3<=in;
out2<=out3;
out1<=out2;
out0<=out1;

end
endmodule
module tb;
reg clk,in;
wire out3,out2,out1,out0;
practice dut(in,clk,out3,out2,out1,out0);
initial
begin
clk=1'b0;
in=0;
#40
in=1'b1;
#10
in=1'b1;
#10;
in=1'b0;
#10
in=1'b1;
#10
$stop();
end
always #5 clk=!clk;
endmodule

13) 4 bit PISO shift register

module piso(in,clk,reset,out);
input [3:0]in;
input clk,reset;
output reg out;
reg [2:0] q;
always @(posedge clk)
begin
if (reset)
begin
q[2]<=in[3];
q[1]<=in[2];
q[0]<=in[1];
out<=in[0];
end
else
begin
q[2]<=1'bx;
q[1]<=q[2];
q[0]<=q[1];
out<=q[0];
end
end
endmodule
module tb;
reg [3:0] in;
reg clk,reset;
wire out;
practice dut(in,clk,reset,out);
initial
begin
clk=1'b0;
reset=1'b1;
in=4'b1001;
#6
reset=1'b0;
end
always #5 clk=~clk;
endmodule

14) 4 bit PIPO shift register

module practice(clk,rst,in,out);
input clk,rst;
input [3:0] in;
output reg [3:0] out;
always @(posedge clk)
begin
if(rst)
begin
out[3]<=in[3];
out[2]<=in[2];
out[1]<=in[1];
out[0]<=in[0];
end
else
begin
out[3]<=1'b0;
out[2]<=out[3];
out[1]<=out[2];
out[0]<=out[1];
end
end
endmodule

module tb;
reg clk,rst;
reg [3:0] in;
wire [3:0] out;
practice dut(clk,rst,in,out);
initial
begin
clk=1'b0;
rst=1'b1;
in=4'b1101;
#6
rst=1'b0;
end
always #5 clk=~clk;
endmodule

15) 4 bit asynchronous Simultaneous “Up” and “Down” Counter

module jkf(j,k,clk,out,outbar,rst);
input j,k,clk,rst;
output reg out,outbar;
wire w1,w2,w3,w4;
always @(negedge clk)
begin
if(rst==1'b1)
begin
out<=1'b0;
outbar<=1'b1;
end
else if(j==1'b0 && k==1'b1)
begin
out<=1'b0;
outbar<=1'b1;
end
else if(j==1'b1 && k==1'b0)
begin
out<=1'b1;
outbar<=1'b0;
end
else if(j==1'b1 && k==1'b1)
begin
out<=~out;
outbar<=~outbar;
end
else
begin
out<=out;
outbar<=outbar;
end

end
endmodule


module asyncountre(clk,rst,outup,outdown);
input clk,rst;
output [3:0] outup,outdown;
jkf d1(1'b1,1'b1,clk,outup[0],outdown[0],rst);
jkf d2(1'b1,1'b1,outdown[0],outup[1],outdown[1],rst);
jkf d3(1'b1,1'b1,outdown[1],outup[2],outdown[2],rst);
jkf d4(1'b1,1'b1,outdown[2],outup[3],outdown[3],rst);

endmodule

module tb;
reg clk,rst;
wire [3:0] outup,outdown;
practice dut(clk,rst,outup,outdown);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
end
always #5 clk=~clk;
endmodule

16) MOD 10 Asynchronous counter 
The below code work fine on simulator(eda playground but not in quartus prime)

module asycounter10(clk,out,rst);
input clk,rst;
output reg [3:0] out;
wire w;
always @(negedge clk or posedge w)
begin
if(rst==1'b1 || w==1'b1 )
out[0]<=1'b0;
else
out[0]<=~out[0];
end
always @(negedge out[0] or posedge w)
begin
if(rst==1'b1 || w==1'b1)
out[1]<=1'b0;
else
out[1]<=~out[1];
end
always @(negedge out[1] or posedge w )
begin
if(rst==1'b1 || w==1'b1)
out[2]<=1'b0;
else
out[2]<=~out[2];
end
always @(negedge out[2] or posedge w )
begin
if(rst==1'b1 || w==1'b1)
out[3]<=1'b0;
else
out[3]<=~out[3];
end
assign  #1 w=out[3]&out[1];//provide delay for correct operation
endmodule

module tb;
reg clk,rst;
wire [3:0] out;
asycounter10 dut(clk,out,rst);
initial
begin
clk=1'b0;
rst=1'b0;
#11
rst=1'b1;
#22
rst=1'b0;
end
always #5 clk=~clk;
endmodule

17) Dual Edge Triggered Flip Flop

module DDFF(in,out,clk,rst);
input in,clk,rst;
output reg out;
reg q1,q2;
always @(posedge clk)
begin
if (rst)
q1<=0;
else
q1<=in;
end
always @(negedge clk)
begin
if (rst)
q2<=0;
else
q2<=in;
end
always @(q1,q2,clk)
begin
if (clk==1'b1)
out=q1;
else
out=q2;
end
endmodule

module tb;
reg in,clk,rst;
wire out;
DDFF dut(in,out,clk,rst);
initial
begin
clk=1'b0;
rst=1'b1;
in=1'b1;
#11
rst=1'b0;
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
end
always #5 clk=~clk;
endmodule

18) Design synchronous counter for the 3-7-0-6-4-1 sequence using D Flip Flop

module syncounter(clk,rst,q);
input clk,rst;
output reg [3:1] q;
always @(posedge clk)
begin
if(rst)
q<=3'b011;
else
begin
q[3]<=((~q[3])&q[2])|(q[2]&(~q[1]))|((~q[3])&(~q[1]));
q[2]<=~q[3];
q[1]<=((~q[3])&q[1])|(q[3]&(~q[2]));
end
end
endmodule
module tb;
reg clk,rst;
wire [3:1] q;
syncounter dut(clk,rst,q);
initial
begin
clk=1'b0;
rst=1'b1;
#7
rst=1'b0;
end
always # 5 clk=~clk;
endmodule

19) 4bit johnson counter

module DFF(clk,rst,in,out,outbar);
input clk,rst,in;
output reg out,outbar;
always @(posedge clk)
begin
if(rst)
begin
out<=1'b0;
outbar<=1'b1;
end
else
begin
out<=in;
outbar<=~in;
end
end
endmodule
module johncounter(clk,rst,out,outbar);
input clk,rst;
output [3:0] out,outbar;
DFF d3(clk,rst,outbar[0],out[3],outbar[3]);
DFF d2(clk,rst,out[3],out[2],outbar[2]);
DFF d1(clk,rst,out[2],out[1],outbar[1]);
DFF d0(clk,rst,out[1],out[0],outbar[0]);
endmodule

module tb;
reg clk,rst;
wire [3:0] out,outbar;
johncounter dut(clk,rst,out,outbar);
initial
begin
clk=1'b0;
rst=1'b1;
#7
rst=1'b0;
end
always #5 clk=~clk;
endmodule

20) 4 bit LFSR circuit
(https://inst.eecs.berkeley.edu/~cs150/sp03/handouts/15/LectureA/lec27-2up.pdf in this website page 1 you can refe
diagram and output)

module LFSR(clk,rst,q);
input clk,rst;
output reg [3:0] q;
always @(posedge clk)
begin
if(rst)
begin
q[3]<=1'b0;
q[2]<=1'b0;
q[1]<=1'b0;
q[0]<=1'b1;
end
else
begin
q[0]<=q[3];
q[1]<=q[3]^q[0];
q[2]<=q[1];
q[3]<=q[2];
end
end
endmodule

module tb;
reg clk,rst;
wire [3:0] q;
practice LFSR(clk,rst,q);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
end
always # 5 clk=~clk;
endmodule

21) 11011 FSM overlapping Morre machine
 module fsm(clk,rst,in,out);
input clk,rst,in;
output reg out;
parameter A=3'b000,B=3'b001,C=3'b010,D=3'b100,E=3'b111,F=3'b110;
reg [2:0] ps,ns;
always @(posedge clk)
begin
if(rst)
ps<=A;
else
ps<=ns;
end
always @(ps,in)
begin
case(ps)
A : begin
ns=in?B:A;
out=1'b0;
end
B : begin
ns=in?C:A;
out=1'b0;
end
C : begin
ns=in?C:D;
out=1'b0;
end
D : begin
ns=in?E:A;
out=1'b0;
end
E : begin
ns=in?F:A;
out=1'b0;
end
F : begin
ns=in?C:D;
out=1'b1;
end
endcase
end
endmodule

module tb;
reg clk,rst,in;
wire out;
fsm dut(clk,rst,in,out);
initial
begin
clk=1'b0;
rst=1'b1;
in=1'b1;
#6
rst=1'b0;
#19
in=1'b1;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b1;
#10;
in=1'b0;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10;
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b1;
end
always #5 clk=~clk;
endmodule

22) 101010  overlapping FSM mealy machine 

module mealy(clk,rst,in,out);
input clk,rst,in;
output reg out;
parameter A=4'b0000,B=4'b0001,C=4'b0010,D=4'b0100,E=4'b1000,F=4'b1100;
reg [3:0] ps,ns;
always @(posedge clk)
begin
if(rst)
ps<=A;
else
ps<=ns;
end

always @(ps,in)
begin
case(ps)
A: begin
ns=in?B:A;
out=1'b0;
end
B: begin
ns=in?B:C;
out=1'b0;
end
C: begin
ns=in?D:A;
out=1'b0;
end
D: begin
ns=in?B:E;
out=1'b0;
end
E: begin
ns=in?F:A;
out=1'b0;
end
F: begin
ns=in?B:E;
out=in?1'b0:1'b1;
end
endcase
end
endmodule

module tb;
reg clk,rst,in;
wire out;
mealy dut(clk,rst,in,out);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
#9
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
end
always #5 clk=~clk;
endmodule

23) 1001 & 010 overlapping mealy FSM

module mealy(clk,rst,in,out);
input clk,rst,in;
output reg out;
parameter S0=4'b0000,S1=4'b0001,S2=4'b0010,S3=4'b0100,S4=4'b1000,S5=4'b1100;
reg [3:0] ns,ps;
always @(posedge clk)
begin
if(rst)
ps<=S0;
else
ps<=ns;
end

always @(ps,in)
begin
case(ps)
S0: begin
ns=in?S1:S4;
out=1'b0;
end
S1: begin
ns=in?S1:S2;
out=1'b0;
end
S2: begin
ns=in?S5:S3;
out=1'b0;
end
S3: begin
ns=in?S5:S4;
out=in?1'b1:1'b0;
end
S4: begin
ns=in?S5:S4;
out=1'b0;
end
S5: begin
ns=in?S1:S2;
out=in?1'b0:1'b1;
end
endcase
end
endmodule

module tb;
reg clk,rst,in;
wire out;
mealy dut(clk,rst,in,out);
initial
begin
clk=1'b0;
rst=1'b1;
in=1'b1;
#6
rst=1'b0;
#9
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
end
always #5 clk=~clk;
endmodule

24) 2's complement of a binary number using Moore FSM

module (clk,rst,in,out);
input clk,rst,in;
output reg out;
parameter A=2'b00,B=2'b01,C=2'b10;
reg [1:0] ps,ns;
always @(posedge clk)
begin
if(rst)
ps<=A;
else
ps<=ns;
end

always @(ps,in)
begin
case(ps)
A : begin
ns=in?B:A;
out=1'b0;
end
B : begin
ns=in?C:B;
out=1'b1;
end
C : begin
ns=in?C:B;
out=1'b0;
end
endcase
end
endmodule

module tb;
reg clk,rst,in;
wire out;
complement dut(clk,rst,in,out);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
#9
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
end
always #5 clk=~clk;
endmodule

25) Vending machine using mealy machine with change
In this, we will get drink bottle when price = 15 , and we have only 5 and 10 avialable

module machine(clk,rst,coin,bottlereceived,change);
input clk,rst;
input [3:0] coin;
output reg bottlereceived;
output reg [3:0] change;
parameter S0=2'b00,S1=2'b01,S2=2'b10;
reg [1:0] ps,ns;

always @(posedge clk)
begin
if(rst)
ps<=S0;
else
ps<=ns;
end

always @(ps,coin)
begin
case(ps)
S0 : begin
ns = (coin==4'b0101) ? S1 : ((coin==4'b1010) ? S2:S0);
bottlereceived = 1'b0;
change = 4'b0000;
end
S1 : begin
ns = (coin==4'b0101) ? S2 : S0;
bottlereceived = (coin==4'b1010) ? 1'b1 : 1'b0;
change = (coin==4'b0000) ? 4'b0101 : 4'b0000;
end
S2 : begin
ns = S0;
bottlereceived = (coin==4'b0101 || coin==4'b1010) ? 1'b1 : 1'b0;
change = (coin==4'b1010)? 4'b0101 : ((coin==4'b0000) ? 4'b1010 : 4'b0000);
end
endcase
end
endmodule

module tb;
reg clk,rst;
reg [3:0] coin;
wire bottlereceived;
wire [3:0] change;
machine dut(clk,rst,coin,bottlereceived,change);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
#9
coin=4'b0101;
#10;
coin=4'b0101;
#10;
coin=4'b0101;
#10;
coin=4'b0101;
#10;
coin=4'b1010;
#10;
coin=4'b1010;
#10;
coin=4'b0101;
#10;
coin=4'b1010;
#10;
coin=4'b1010;
#10;
coin=4'b1010;
#10;
coin=4'b0000;
end
always #5 clk=~clk;
endmodule

26) single port SRAM with Synchronous read/write

module sram(clk,datain,dataout,enablewrite,readaddress,writeaddress);
input clk,enablewrite;
input [7:0] datain;
input [5:0] readaddress,writeaddress;
output reg [7:0] dataout;
reg [7:0] ram [63:0];

always @(posedge clk)
begin
if(enablewrite)
ram[writeaddress]<=datain;
dataout<=ram[readaddress];
end
endmodule

module tb;
reg clk,enablewrite;
reg [5:0] readaddress,writeaddress;
reg [7:0] datain;
wire [7:0] dataout;
sram dut(clk,datain,dataout,enablewrite,readaddress,writeaddress);
initial
begin
clk=1'b0;
enablewrite=1'b0;
datain=8'b00000000;
#12
enablewrite=1'b1;
datain=8'b11110000;
writeaddress=6'b000000;
readaddress=6'b000000;
#10
datain=8'b11111111;
writeaddress=6'b000000;
readaddress=6'b000000;

end
initial
begin
#30
$finish();
end
always #5 clk=~clk;
endmodule

27) Synchronous FIFO

module fifo(clk,rst,wen,ren,data,dataout,full,empty);
input clk,rst,wen,ren;
input [7:0] data;
output reg [7:0] dataout;
output full,empty;
reg [7:0] memory [15:0];
reg [3:0] wrptr,rdptr;
integer i;
always @(posedge clk)
begin
if (rst)
begin
for(i=0;i<16;i=i+1)
memory[i]=8'b00000000;
wrptr<=4'b0000;
dataout<=8'b00000000;
rdptr<=4'b0000;
end
// write
else if (wen==1'b1)
begin
if (wrptr <  4'b1111)
begin
memory[wrptr]<=data;
wrptr<=wrptr+1'b1;
end
else if(wrptr==4'b1111)
begin
memory[wrptr]<=data;
end
end

//read
else if(ren==1'b1)
begin
if(rdptr!=wrptr)
begin
dataout<=memory[rdptr];
memory[rdptr]<=8'b00000000;
rdptr<=rdptr+1'b1;
end
else if(rdptr==wrptr)
begin
dataout<=memory[rdptr];
memory[rdptr]<=8'b00000000;
wrptr<=4'b0000;
rdptr<=4'b0000;
end
end
end
assign empty=(rdptr==wrptr)?1'b1:1'b0;
assign full=(wrptr==4'b1111)?1'b1:1'b0;
endmodule

module tb;
reg clk,rst,wen,ren;
reg [7:0] data;
wire [7:0] dataout;
wire full,empty;
fifo dut(clk,rst,wen,ren,data,dataout,full,empty);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
wen=1'b1;
#9
data=8'b01010101;
#10;
data=8'b10101010;
#10;
data=8'b00001111;
#10;
data=8'b11110000;
#10;
data=8'b00110011;
#10;
data=8'b11001100;
#10;
data=8'b11100011;
#10;
data=8'b00011100;
#5;
wen=1'b0;
#5
ren=1'b1;
end
always #5 clk=~clk;
endmodule

28) Generate output = 1 for 4 clock cycle and for next 4 clock cycle output = 0. Repeat this sequence for forever

module clk4(clk,rst,out);
input clk,rst;
output reg out;
reg [3:0] pose,nege;
always @(posedge clk)
begin
if (rst)
begin
pose=4'b0000;
nege=4'b0000;
out=1'b0;
end
else
begin
if((pose<4'b0100) && ((nege==4'b0000) || (nege>=4'b0100)))
begin
out=1'b1;
pose=pose+1'b1;
nege=4'b0000;
end
else if (pose >= 4'b0100)
begin
out=1'b0;
nege=nege+1'b1;
pose=4'b0000;
end
else if (nege < 4'b0100)
begin
out=1'b0;
nege=nege+1'b1;
pose=4'b0000;
end
end
end
endmodule

module tb;
reg clk,rst;
wire out;
clk4 dut(clk,rst,out);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
end
always # 5 clk=~clk;
endmodule

29) Moore FSM gives output 1 when detects even number of ones recived else output is 0

module even(clk,rst,in,out);
input clk,rst,in;
output reg out;
parameter S0=3'b100,S1=3'b010,S2=3'b001;
reg [2:0] ps,ns;
always @(posedge clk)
begin
if(rst)
ps<=S0;
else
ps<=ns;
end

always @(ps,in)
begin
case(ps)
S0 : begin
ns=in?S1:S0;
out=1'b0;
end
S1 : begin
ns=in?S2:S1;
out=1'b0;
end
S2 : begin
ns=in?S1:S0;
out=1'b1;
end
endcase
end
endmodule

module tb;
reg clk,rst,in;
wire out;
even dut(clk,rst,in,out);
initial
begin
clk=1'b0;
rst=1'b1;
#6
rst=1'b0;
#9
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b1;
#10
in=1'b0;
#10
in=1'b1;
#10
in=1'b1;
end
always #5 clk=~clk;
endmodule

30) Design a synchronous Traffic light controller cicuit

module trafficlight(clk,rst,red,green,yellow);
input clk,rst;
output  red,green,yellow;
parameter GREEN = 3'b000 ,YELLOW = 3'b001 ,RED = 3'b010 ,REDYELLOW = 3'b100 ,WAITED = 3'b111;
reg [2:0] ps,ns;
reg [5:0] count;

always @(posedge clk)
begin
if(rst)
ps <= GREEN;
else
ps <= ns;
end

always @(ps,count)
begin
case(ps)
GREEN : ns = (count == 6'b001111) ? YELLOW : GREEN;
YELLOW : ns = (count == 6'b010100) ? RED : YELLOW;
RED : ns = (count == 6'b011110) ? REDYELLOW : RED;
REDYELLOW : ns = (count == 6'b100011) ? WAITED : REDYELLOW;
WAITED : ns = GREEN;
endcase
end

always @(posedge clk)
begin
if(rst)
count <= 5'b000000;
else if (ps == WAITED)
count <= 5'b000000;
else
count <= count + 1'b1;
end

assign red = (ps == RED || ps == REDYELLOW) ? 1'b1 : 1'b0;
assign yellow = (ps == YELLOW || ps == REDYELLOW) ? 1'b1 : 1'b0;
assign green = (ps == GREEN) ? 1'b1 : 1'b0;
endmodule

module tb;
reg clk,rst;
wire red,green,yellow;
trafficlight dut(clk,rst,red,green,yellow);

initial
begin
clk = 1'b0;
rst = 1'b1;
#6
rst = 1'b0;

end
always #5 clk = ~clk;
endmodule

31) Lfsr5 ( https://hdlbits.01xz.net/wiki/Lfsr5)
module lfsr5(clk,reset,q);
    input clk,reset;
    output reg [4:0] q;
    always @(posedge clk)
        begin
            if(reset)
                q <= 5'h1;
            else
                begin
                    q[4] <= 1'b0^q[0];
                    q[3] <= q[4];
                    q[2] <= q[0]^q[3];
                    q[1] <= q[2];
                    q[0] <= q[1];
                end
        end
endmodule

32) A 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and
   carry out. (https://hdlbits.01xz.net/wiki/Adder100)

 module Fulladder(in1,in2,carryin,sum,carryout);
    input in1,in2,carryin;
    output sum,carryout;
    assign sum = in1^in2^carryin;
    assign carryout = in2&carryin | (in1)&(in2|carryin);
endmodule


module adder100(a,b,cin,cout,sum);
    input [99:0] a,b;
    input cin;
    output cout;
    output [99:0] sum;
    wire [98:0] w;
    Fulladder f1(a[0],b[0],cin,sum[0],w[0]);
    genvar i;
    generate
        begin
            for( i = 1; i<=98 ; i=i+1)
                begin : adder
                    Fulladder f2(a[i],b[i],w[i-1],sum[i],w[i]);
                end
        end
    endgenerate
    Fulladder f3(a[99],b[99],w[98],sum[99],cout);
endmodule

33) module that outputs a 32 bit number. Write verilog code to grab bits 8-14 bits.

module Grabbits(in,out);

input [31:0] in;

output reg [7:0] out;

reg [31:0] temp;

integer i;

always @(in)

begin

temp = in >> 8;

for( i = 0; i <= 7; i = i+1)
begin

out[i] = temp[0] & 1'b1;

temp = temp >> 1;

end
end

endmodule

module tb;

reg [31:0] in;

wire [7:0] out;

Grabbits dut(in,out);

initial

begin
in = 32'b00000000000000000101010100000000;
end
endmodule

34) Finite state machine (FSM) for an automatic reversible 6 modulo counter as follows: 
    The counter counts 0, 1, 2, 3, 4, 5 (when  input is  0) and reverses: 5 4, 3, 2, 1, 0 
    (when input is 1)

module count0to5(clk,rst,in,out);

input clk,rst,in;
output reg [3:0] out;
parameter A = 4'b0000, B = 4'b0001, C = 4'b0010, D = 4'b0011, E = 4'b0100, F = 4'b0101,  G = 4'b0111, H = 4'b1000,I = 4'b1001, J = 4'b1010, K = 4'b1011, L = 4'b1100;
reg [3:0] ps, ns;

always @(posedge clk)
begin
if(rst)
ps <= A;
else
ps <= ns;
end

always @(ps,in)
begin
case (ps)
A : begin
ns = B;
out = 4'b0000;
end

B : begin
ns = C;
out = 4'b0001;
end

C : begin
ns = D;
out = 4'b0010;
end

D : begin
ns = E;
out = 4'b0011;
end

E : begin
ns = F;
out = 4'b0100;
end

F : begin
ns = in ? G : A;
out = 4'b0101;
end

G : begin
ns = H;
out = 4'b0101;
end

H : begin
ns = I;
out = 4'b0100;
end

I : begin
ns = J;
out = 4'b0011;
end

J : begin
ns = K;
out = 4'b0010;
end

K : begin
ns = L;
out = 4'b0001;
end

L : begin
ns = in ? A : G; 
out = 4'b0000;
end
endcase
end
endmodule

module tb;

reg clk,rst,in;
wire[3:0] out;

count0to5 dut(clk,rst,in,out);

initial
begin
clk = 1'b0;
rst = 1'b1;
in = 1'b1;
#10;
rst = 1'b0;
#60;
in = 1'b0;
end

always # 5 clk = ~clk;

endmodule

35) Simple and basic UART transmitter which transfer 8 bit data frame

module uarttx(clk,rst,data_in,done,data_out,stop_bit,start_bit);

input clk,rst,data_in;
output done,data_out,stop_bit,start_bit;

parameter idle = 3'b000, start = 3'b001, transfer = 3'b010, endd = 3'b100;
reg [2:0] ps,ns;
reg [3:0] count;

always @(posedge clk)
begin
if(rst)
ps <= idle;
else
ps <= ns;
end


always @(ps,data_in,count)
begin
case(ps)
idle : ns = start;
start : ns = data_in ? start : transfer;
transfer : ns = (count == 4'b1000) ? (data_in ? endd : start) : transfer;
endd : ns = data_in ? start : transfer;
endcase
end

always @(posedge clk)
begin
if(rst)
count <= 4'b0000;
else if(ps == transfer)
count <= count + 1'b1;
else
count <= 4'b0000;
end

assign done = (ps == endd) ? 1'b1 : 1'b0;
assign data_out = (ps == transfer) ? data_in : 1'bx;
assign start_bit = (ps == start) ? 1'b1 : 1'b0;
assign stop_bit = (count == 4'b1000) ? data_in : 1'b0; 
endmodule

module tb;
reg clk,rst,data_in;
wire done,data_out,stop_bit,start_bit;
uarttx dut(clk,rst,data_in,done,data_out,stop_bit,start_bit);

initial
begin
clk = 1'b0;
rst = 1'b1;
data_in = 1'b1;
#6
rst = 1'b0;
#19
data_in = 1'b0;
#10
data_in = 1'b1;
#10;
data_in = 1'b1;
#10;
data_in = 1'b1;
#10;
data_in = 1'b1;
#10;
data_in = 1'b1;
#10;
data_in = 1'b1;
#10;
data_in = 1'b1;
#10;
data_in = 1'b0;
#10;
data_in = 1'b1;
#40;
data_in = 1'b0;
#10
data_in = 1'b1;
#10;
data_in = 1'b0;
#10;
data_in = 1'b1;
#10;
data_in = 1'b0;
#10;
data_in = 1'b1;
#10;
data_in = 1'b0;
#10;
data_in = 1'b1;
#10;
data_in = 1'b0;
#10;
data_in = 1'b1;

end

always #5 clk = ~clk;
endmodule

36) Solution to HDLbits problem (https://hdlbits.01xz.net/wiki/Exams/review2015_fsmseq)

module top_module(clk ,reset ,data ,start_shifting);
    input clk,reset,data;
    output start_shifting;
    parameter S0 = 4'b0000 ,S1 = 4'b0001 ,S2 = 4'b0010 ,S3 = 4'b0100 ,S4 = 4'b1000;
    reg [3:0] ps ,ns;
    
    always @(posedge clk)
        begin
            if(reset)
                ps <= S0;
            else
                ps <= ns;
        end
    
    always @(ps,data)
        begin
            case(ps)
                S0 : ns = data ? S1 : S0;
                S1 : ns = data ? S2 : S0;
                S2 : ns = data ? S2 : S3;
                S3 : ns = data ? S4 : S0;
                S4 : ns = S4;
            endcase
        end
    
    assign start_shifting = (ps == S4) ? 1'b1 : 1'b0;
    
endmodule

37) Solution to HDLBITS Exams/2013 q2afsm (https://hdlbits.01xz.net/wiki/Exams/2013_q2afsm)

module top_module (clk ,resetn ,r ,g);
    input clk,resetn;
    input [3:1] r;
    output [3:1] g;
    
    parameter A = 3'b000 ,B = 3'b001 ,C = 3'b010 ,D = 3'b100;
    reg [2:0] ps,ns;
    
    always@(posedge clk)
        if(~resetn)
            ps <= A;
     else
            ps <= ns;
    
    always@(ps ,r)
        case(ps)
            A : ns = r[1] ? B : (r[2] ? C : (r[3] ? D : A));
            B : ns = r[1] ? B :A;
            C : ns = r[2] ? C :A;
            D : ns = r[3] ? D :A;
        endcase
    
    assign g[1] = (ps == B) ? 1'b1 : 1'b0;
    assign g[2] = (ps == C) ? 1'b1 : 1'b0;
    assign g[3] = (ps == D) ? 1'b1 : 1'b0;
    
endmodule

//  Lemmings series 

38) HDLbits solution of Lemmings1(https://hdlbits.01xz.net/wiki/Lemmings1)

module top_module(clk ,areset ,bump_left ,bump_right ,walk_left ,walk_right);
    
    input clk ,areset ,bump_left ,bump_right;
    output walk_left ,walk_right;
    
    parameter Left = 2'b00 , Right = 2'b01;
    reg [1:0] ps ,ns;
    
    always @(posedge clk or posedge areset)
        begin
            if(areset)
                ps <= Left;
            else
                ps <= ns;
        end
    
    always @(ps ,bump_left ,bump_right)
        begin
            case(ps)
                Left  : ns = bump_left  ? Right : Left;
                Right : ns = bump_right ? Left  : Right;
            endcase
        end
    
    assign walk_left  = (ps == Left)  ? 1'b1 : 1'b0;
    assign walk_right = (ps == Right) ? 1'b1 : 1'b0;
    
endmodule

39) HDLbits solution of Lemmings2(https://hdlbits.01xz.net/wiki/Lemmings2)

module top_module(clk ,areset ,bump_left ,bump_right ,ground ,walk_left ,walk_right ,aaah);
    
    input clk ,areset ,bump_left ,bump_right ,ground;
    output walk_left ,walk_right ,aaah;
    
    parameter LEFT  = 3'b000 ,RIGHT = 3'b001 ,FALL_L = 3'b010 ,FALL_R = 3'b100;
    reg [2:0] ps ,ns;
    
    always @(posedge clk or posedge areset)
        begin
            if(areset)
                ps <= LEFT;
            else
                ps <= ns;
        end
    
    always @(ps ,bump_left ,bump_right ,ground)
        begin
            case(ps)
                LEFT   : ns = ~ground ? FALL_L : (bump_left  ? RIGHT :  LEFT);
                RIGHT  : ns = ~ground ? FALL_R : (bump_right ? LEFT  : RIGHT);
                FALL_L : ns = ~ground ? FALL_L :  LEFT;
                FALL_R : ns = ~ground ? FALL_R : RIGHT;
            endcase
        end
    
    assign walk_left  = (ps ==  LEFT) ? 1'b1 : 1'b0;
    assign walk_right = (ps == RIGHT) ? 1'b1 : 1'b0;
    assign aaah = (ps == FALL_L || ps == FALL_R) ? 1'b1 : 1'b0;
    
endmodule

40) HDLbits solution of Lemmings3(https://hdlbits.01xz.net/wiki/Lemmings3)

module top_module(clk ,areset ,bump_left ,bump_right ,ground , dig, walk_left ,walk_right ,aaah ,digging);
    
    input clk ,areset ,bump_left ,bump_right ,ground , dig;
    output walk_left ,walk_right ,aaah ,digging;
    
    parameter WalkL = 4'b0000 ,WalkR = 4'b1000 ,FallL = 4'b0100 ,FallR = 4'b0010 ,DigL = 4'b0001 ,DigR = 4'b1111;
    reg [3:0] ps ,ns;
    
    always @(posedge clk or posedge areset)
        begin
            if(areset)
                ps <= WalkL;
            else
                ps <= ns;
        end
    
    always @(ps ,bump_left ,bump_right ,ground , dig)
        begin
            case(ps)
                WalkL : ns = !ground ? FallL : (dig ? DigL : (bump_left  ? WalkR : WalkL));
                WalkR : ns = !ground ? FallR : (dig ? DigR : (bump_right ? WalkL : WalkR));
                FallL : ns = !ground ? FallL : WalkL;
                FallR : ns = !ground ? FallR : WalkR;
                DigL  : ns = !ground ? FallL : DigL;
                DigR  : ns = !ground ? FallR : DigR;
            endcase
        end
    
    assign walk_left  = (ps == WalkL) ? 1'b1 : 1'b0;
    assign walk_right = (ps == WalkR) ? 1'b1 : 1'b0;
    assign aaah    = (ps == FallL || ps == FallR) ? 1'b1 : 1'b0;
    assign digging = (ps == DigL  || ps == DigR)  ? 1'b1 : 1'b0;
    
endmodule

41) HDLbits solution of Exams/2014 q3fsm(https://hdlbits.01xz.net/wiki/Exams/2014_q3fsm)

module top_module(clk ,reset ,s ,w ,z);
    
    input clk ,reset ,s ,w;
    output reg z;
    
    parameter A = 1'b1 ,B = 1'b0;
    reg ps ,ns;
    reg [1:0] countclk ,countone;
    
    always @(posedge clk)
        begin
            if(reset)
                ps <= A;
            else
                ps <= ns;
        end
    
    always @(ps ,s)
        case(ps)
            A : ns = s ? B : A;
            B : ns = B;
        endcase
    
    always @(posedge clk)
        begin
            if(reset)
                begin
                    countclk <= 2'b00;
                    countone <= 2'b00;
                    z        <= 1'b0;
                end
            else
                begin
                    if(ps == B)
                        begin
                            countclk <= countclk + 1'b1;
                            if(countclk == 2'b10)
                                begin
                                    countclk <= 1'b0;
                                    if(w == 1)
                                        begin
                                            countone <= countone + 1'b1;
                                            if(countone == 2'b10 && w != 1'b1)
                                                begin
                                                    z <= 1'b1;
                                                    countone <= 1'b0;
                                                end
                                            else
                                                begin
                                                    if(countone == 1'b1 && w == 1'b1)
                                                        begin
                                                            z <= 1'b1;
                                                            countone <= 1'b0;
                                                        end
                                                    else
                                                        begin
                                                            z <= 1'b0;
                                                            countone <= 1'b0;
                                                        end
                                                end
                                        end
                                    else
                                        begin
                                            if(countone == 2'b10)
                                                begin
                                                    z <= 1;
                                                    countone <= 1'b0;
                                                end
                                            else
                                                begin
                                                    z <= 1'b0;
                                                    countone <= 1'b0;
                                                end
                                        end
                                end
                            else
                                begin
                                    z <= 1'b0;
                                    if(w == 1'b1)
                                        countone <= countone + 1'b1;
                                    else
                                        countone <= countone;
                                end
                        end
                    else
                        z <= 1'b0;
                    
                end
        end
    
endmodule

42) 4bit wallace multiplier 

module HalfAdder(a ,b ,sum ,carry);

input a ,b;
output sum ,carry;

xor(sum ,a ,b);
and(carry ,a ,b);

endmodule

module FullAdder(a ,b ,c ,sum ,carry);

input a ,b ,c;
output sum ,carry;

wire [2:0] nets;

xor(sum ,a ,b ,c);
and(nets[0] ,a ,b);
and(nets[1] ,a ,c);
and(nets[2] ,b ,c);
or(carry ,nets[0] ,nets[1] ,nets[2]);

endmodule

module Wallacemultiplier(A ,B ,Out);

input [3:0] A ,B;
output [7:0] Out;

wire [15:1] nets;
wire [5:0] sum;
wire [10:0] carry;

and(Out[0] ,A[0] ,B[0]);
and(nets[1] ,A[0] ,B[1]);
and(nets[2] ,A[1] ,B[0]);
and(nets[3] ,A[2] ,B[0]);
and(nets[4] ,A[0] ,B[2]);
and(nets[5] ,A[1] ,B[1]);
and(nets[6] ,A[2] ,B[1]);
and(nets[7] ,A[3] ,B[0]);
and(nets[8] ,A[0] ,B[3]);
and(nets[9] ,A[1] ,B[2]);
and(nets[10] ,A[3] ,B[1]);
and(nets[11] ,A[1] ,B[3]);
and(nets[12] ,A[2] ,B[2]);
and(nets[13] ,A[2] ,B[3]);
and(nets[14] ,A[3] ,B[2]);
and(nets[15] ,A[3] ,B[3]);

HalfAdder HA1(nets[8] ,nets[9] ,sum[0] ,carry[0]);
HalfAdder HA2(nets[11] ,nets[12] ,sum[1] ,carry[1]);

FullAdder FA1(nets[4] ,nets[5] ,1'b0 ,sum[2] ,carry[2]);
FullAdder FA2(nets[6] ,nets[7] ,sum[0] ,sum[3] ,carry[3]);
FullAdder FA3(nets[10] ,carry[0] ,sum[1] ,sum[4] ,carry[4]);
FullAdder FA4(nets[13] ,nets[14] ,carry[1] ,sum[5] ,carry[5]);

HalfAdder HA3(nets[1] ,nets[2] ,Out[1] ,carry[6]);
FullAdder FA5(nets[3] ,carry[6] ,sum[2] ,Out[2] ,carry[7]);
FullAdder FA6(carry[2] ,carry[7] ,sum[3] ,Out[3] ,carry[8]);
FullAdder FA7(carry[3] ,carry[8] ,sum[4] ,Out[4] ,carry[9]);
FullAdder FA8(carry[4] ,carry[9] ,sum[5] ,Out[5] ,carry[10]);
FullAdder FA9(carry[5] ,carry[10] ,nets[15] ,Out[6] ,Out[7]);

endmodule


module tb;

reg [3:0] A ,B;
wire [7:0] Out;

Wallacemultiplier dut(A ,B ,Out);

initial
begin
A = 4'b0011;
B = 4'b1100;
#10;
A = 4'b1010;
B = 4'b1110;
#10;
A = 4'b1111;
B = 4'b1111;
#10;
A = 4'b0000;
B = 4'b0000;
end

endmodule

43) Design an FSM- finite state machine to check whether the two inputs A and B have the same value for the
previous three samples. Use Mealy machine for the design.

module checksequence(clk ,rst ,inputsequence1 ,inputsequence2 ,out);

input clk ,rst ,inputsequence1 ,inputsequence2;
output  out;

parameter A = 3'b000 ,B = 3'b001 ,C = 3'b100;
reg [2:0] ps ,ns;

always @(posedge clk)
begin
if(rst)
ps <= A;
else
ps <= ns;
end


always @(ps ,inputsequence1 ,inputsequence2)
begin
case(ps)
A : ns  = (inputsequence1 == inputsequence2) ? B : A;
B : ns  = (inputsequence1 == inputsequence2) ? C : A;
C : ns  = (inputsequence1 == inputsequence2) ? C : A;
endcase
end

assign out = ((inputsequence1 == inputsequence2) && (ps == C)) ? 1'b1 : 1'b0;

endmodule

module tb;

reg clk ,rst ,inputsequence1 ,inputsequence2;
wire out;

checksequence dut(clk ,rst ,inputsequence1 ,inputsequence2 ,out);

always #5 clk = ~clk;

initial
begin
clk = 1'b0;
rst = 1'b1;
#6;
rst = 1'b0;
#9;
inputsequence1 = 1'b0;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b0;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b0;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b1;
inputsequence2 = 1'b1;
#10;
inputsequence1 = 1'b0;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b1;
inputsequence2 = 1'b1;
#10;
inputsequence1 = 1'b0;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b0;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b1;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b0;
inputsequence2 = 1'b1;
#10;
inputsequence1 = 1'b1;
inputsequence2 = 1'b0;
#40
inputsequence1 = 1'b0;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b0;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b0;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b1;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b0;
inputsequence2 = 1'b1;
#10;
inputsequence1 = 1'b0;
inputsequence2 = 1'b1;
#10;
inputsequence1 = 1'b1;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b1;
inputsequence2 = 1'b1;
#10;
inputsequence1 = 1'b1;
inputsequence2 = 1'b1;
#10;
inputsequence1 = 1'b0;
inputsequence2 = 1'b1;
#10;
inputsequence1 = 1'b0;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b0;
inputsequence2 = 1'b0;
#10;
inputsequence1 = 1'b1;
inputsequence2 = 1'b1;

end

endmodule

44) Design a finite state machine for a serial binary input which is divisible by 5

module fsm5(clk ,rst ,in ,out);

input clk ,rst ,in;
output out;

parameter A = 5'b00001 ,R1 = 5'b00010 ,R2 = 5'b00100 ,R3 = 5'b01000 ,R4 = 5'b10000 ,R0 = 5'b00000;
reg [4:0] ps ,ns;

always @(posedge clk)
begin
if(rst)
ps <= A;
else
ps <= ns;
end

always @(ps ,in)
begin
case(ps)
A  : ns = in ? R1 : A;
R1 : ns = in ? R3 : R2;
R2 : ns = in ? R0 : R4;
R3 : ns = in ? R2 : R1;
R4 : ns = in ? R4 : R3;
R0 : ns = in ? R1 : R0;
endcase
end

assign out = (ps == R0) ? 1'b1 : 1'b0;

endmodule

module tb;

reg clk ,rst ,in;
wire out;

fsm5 dut(clk ,rst ,in ,out);

initial
begin
clk = 1'b0;
rst = 1'b1;
in = 1'b1;
#6
rst = 1'b0;
#9
in = 1'b1;
#10
in = 1'b1;
#10
in = 1'b0;
#10
in = 1'b0;
#10
in = 1'b0;
#10
in = 1'b0;
#10
in = 1'b1;
#10
in = 1'b0;
#10
in = 1'b0;
#10
in = 1'b1;
#10
in = 1'b1;
#40
in = 1'b1;
#10
in = 1'b0;
#10
in = 1'b1;
#10
in = 1'b1;
#10
in = 1'b0;
#10
in = 1'b1;
#10
in = 1'b0;

#40
in = 1'b1;
#10
in = 1'b0;
#10
in = 1'b0;
#10
in = 1'b0;
#10
in = 1'b1;
#10
in = 1'b0;
#10
in = 1'b0;
#10
in = 1'b1;
#10
in = 1'b0;
#10
in = 1'b0;
#10
in = 1'b1;
#10
in = 1'b1;

#40
in = 1'b1;
#10
in = 1'b1;
#10
in = 1'b0;
#10
in = 1'b1;
#10
in = 1'b1;
#10
in = 1'b1;
#10
in = 1'b0;
#10
in = 1'b1;
#10
in = 1'b1;
#10
in = 1'b1;
#10
in = 1'b1;
#40
in = 1'b1;
#10;
in = 1'b1;
#10;
in = 1'b1;
#10;
in = 1'b0;
#10;
in = 1'b0;
#10;
in = 1'b0;
#10;
in = 1'b0;
#10;
in = 1'b0;
#10;
in = 1'b0;
#10;
in = 1'b0;
#10;
in = 1'b1;
end

always #5 clk = ~clk;

endmodule

45) Design a finite state machine for a serial binary input which is divisible by 4

module fsm4(clk ,rst ,in ,out);

input clk ,rst ,in;
output out;

parameter idle = 4'b0000 ,remone = 4'b0001 ,remtwo = 4'b0010 ,remthree = 4'b0100 ,remzero = 4'b1000;
reg [3:0] ps ,ns;

always @(posedge clk)
begin
if(rst)
ps <= idle;
else
ps <= ns;
end

always @(ps ,in)
begin
case(ps)
idle     : ns = in ? remone   : idle;
remone   : ns = in ? remthree : remtwo;
remtwo   : ns = in ? remone   : remzero;
remthree : ns = in ? remthree : remtwo;
remzero  : ns = in ? remone   : remzero;
endcase
end

assign out = (ps == remzero) ? 1'b1 : 1'b0;

endmodule

module tb;

reg clk ,rst ,in;
wire out;

fsm4 dut(clk ,rst ,in ,out);

always #5 clk = ~clk;

initial
begin
clk = 1'b0;
rst = 1'b1;
#6
rst = 1'b0;
#9;
in = 0;
#20;
in = 1'b1;
#10;
in = 1'b1;
#10;
in = 1'b1;
#10;
in = 1'b0;
#20;
in = 1'b1;
#10;
in = 1'b1;
#10;
in = 1'b0;
#10;
in = 1'b1;
#10;
in = 1'b1;
#10;
in = 1'b1;
#20;
in = 1'b1;
#10 ;
in = 1'b0;
#10 ;
in = 1'b0;
#10 ;
in = 1'b1;
end

endmodule

46) CLOCK TIMER(24 HOUR SYSTEM)

module clock(clk ,rst ,hr ,mm ,ss);

input clk ,rst;
output reg [7:0] hr ,mm ,ss;

integer hour ,min ,sec;

always @(posedge clk)
begin
if(rst)
begin
hr   <= 8'b0000_0000;
mm   <= 8'b0000_0000;
ss   <= 8'b0000_0000;
hour <= 0;
min  <= 0;
sec  <= 0;
end
else
begin
sec <= sec + 1;
ss  <= sec;
if(ss == 59)
begin
sec <= 0;
ss  <= 8'b0000_0000;
min <= min + 1;
mm  <= min + 1;
if(mm == 59)
begin
min  <= 0;
mm   <= 8'b0000_0000;
hour <= hour + 1;
hr   <= hour + 1;
if(hr == 23)
begin
hour <= 0;
hr   <= 8'b0000_0000;
end
end
end
end
end

endmodule

module tb;

reg clk ,rst;
wire [7:0] hr ,mm ,ss;

clock dut(clk ,rst ,hr ,mm ,ss);

always #5 clk = ~clk;

initial
begin
clk = 1'b0;
rst = 1'b1;
#6
rst = 1'b0;
end

endmodule

47) LIFO BUFFER

module lifo(clk ,rst ,en ,rw ,datain ,dataout ,empty ,full);

input  clk ,rst ,en ,rw;
input  [7:0] datain;
output empty ,full;
output reg [7:0] dataout;

reg [7:0] lifobuffer[15:0];
reg [4:0] skptr;

integer i;

always @(posedge clk)
begin
if(rst)
begin
for(i = 0 ;i<=15 ;i = i + 1)
lifobuffer[i] = 8'b0000_0000;
skptr         = 5'b00000;
end
else if(!full & en & !rw)
begin
lifobuffer[skptr] = datain;
skptr             = skptr + 1'b1;
end
else if(!empty & en & rw)
begin
skptr             = skptr - 1'b1;
dataout           = lifobuffer[skptr];
lifobuffer[skptr] = 8'b0000_0000;
end
end

assign full  = (skptr == 5'b10000) ? 1'b1 : 1'b0;
assign empty = (skptr == 5'b00000) ? 1'b1 : 1'b0;

endmodule


module tb;

reg  clk ,rst ,en ,rw;
reg  [7:0] datain;
wire empty ,full;
wire [7:0] dataout;

lifo dut(clk ,rst ,en ,rw ,datain ,dataout ,empty ,full);


always #5 clk = ~clk;

initial
begin
clk = 1'b0;
rst = 1'b1;
#6
rst = 1'b0;
en  = 1'b1;
#9;
rw     = 1'b0;
datain = 8'b1000_0001;
#10;
datain = 8'b1000_0010;
#10;
datain = 8'b1000_0011;
#10;
datain = 8'b1000_0111;
#10;
datain = 8'b1000_1111;
#10;
datain = 8'b1001_1111;
#10;
datain = 8'b1011_1111;
#10;
datain = 8'b1111_1111;
#10;
datain = 8'b1111_1000;
#10;
datain = 8'b1111_0000;
#10;
datain = 8'b1010_1010;
#10;
datain = 8'b0000_1111;
#10;
datain = 8'b1111_1111;
#10;
datain = 8'b1000_0001;
#10;
datain = 8'b0000_1111;
#10;
datain = 8'b1001_1001;
#10;
rw = 1'b1;
end

endmodule

48) HDLBITS(https://hdlbits.01xz.net/wiki/Exams/m2014_q6)

module top_module(clk ,reset ,w ,z);
    
    input clk ,reset ,w;
    output  z;
    
    parameter A = 5'b00000 ,B = 5'b00001 ,C = 5'b00010 ,D = 5'b00100 ,E = 5'b01000 ,F = 5'b10000;
    reg [4:0] ps ,ns;
    
    always @(posedge clk)
        begin
            if(reset)
                ps <= A;
            else
                ps <= ns;
        end
    
    always @(ps ,w)
        begin
            case(ps)
                A : ns = w ? A : B;
                B : ns = w ? D : C;
                C : ns = w ? D : E;
                D : ns = w ? A : F;
                E : ns = w ? D : E;
                F : ns = w ? D : C;
            endcase
        end
    
    assign z = ( ps == E || ps == F ) ? 1'b1 : 1'b0;
    
endmodule

49) ALU DESIGN 

module aludesign(A ,B ,operation ,result);

input [3:0] A ,B ,operation;
output reg [7:0] result;

always @(A or B  or operation)
begin
case(operation)
4'b0000 : result = A + B;    //Addition
4'b0001 : result = A - B;    //Substraction
4'b0010 : result = A / B;    //Divison
4'b0011 : result = A * B;    //Multiplication
4'b0101 : result = A & B;    //and operation
4'b0110 : result = A | B;    //or operation
4'b0111 : result = A ^ B;    //xor operation
4'b1000 : result = ~(A ^ B); //xnor operation
4'b1001 : result = ~(A & B); //nand operation
4'b1010 : result = ~(A | B); //nor operation
4'b1011 : result = (A > B) ? 1'b1 : 1'b0; // if A > B -> 1
4'b1100 : result = (B > A) ? 1'b1 : 1'b0; // if B > A -> 1
4'b1101 : result = {A ,B};   //concatenation operation
default : result = A + B;    //Addition
endcase
end

endmodule

module tb;

reg [3:0] A ,B ,operation;
wire [7:0] result;

aludesign dut(A ,B ,operation ,result);

initial
begin
A = 4'b1111;
B = 4'b1111;
operation = 4'b0000;
#10;
A = 4'b1111;
B = 4'b1111;
operation = 4'b0001;
#10;
A = 4'b1111;
B = 4'b1111;
operation = 4'b0010;
#10;
A = 4'b1111;
B = 4'b1111;
operation = 4'b0101;
#10;
A = 4'b1111;
B = 4'b1111;
operation = 4'b1101;
#10;
A = 4'b1101;
B = 4'b1111;
operation = 4'b1011;
#10;
A = 4'b1110;
B = 4'b1111;
operation = 4'b1100;
end

endmodule

50) 4 Bit Controlled Buffer Register

module flipflop(clk ,rst ,in ,out);

input clk ,rst ,in;
output reg out;

always @(posedge clk)
begin
if(~rst) // reset is active low
out <= 1'b0;
else
out <= in;
end

endmodule

module combcircuit(in1 ,in2 ,in3 ,out1);//in3 output of FF and in2 is the main input and in1 is load

input in1 ,in2 ,in3;
output out1;
wire w1 ,w2 ,w3;

and a1(w1 ,in1 ,in2);
not n1(w3 ,in1);
and a2(w2 ,w3 ,in3);
or  o1(out1 ,w1 ,w2);

endmodule

module buffercontroller(clk ,clr ,load ,datain ,dataout);

input clk ,clr ,load;
input  [3:0] datain;
output [3:0] dataout;

wire [3:0] w;

combcircuit c1(load ,datain[0] ,dataout[0]  ,w[0]);
flipflop    f1(clk  ,clr   ,w[0]      ,dataout[0]);
combcircuit c2(load ,datain[1] ,dataout[1]  ,w[1]);
flipflop    f2(clk  ,clr   ,w[1]      ,dataout[1]);
combcircuit c3(load ,datain[2] ,dataout[2]  ,w[2]);
flipflop    f3(clk  ,clr   ,w[2]      ,dataout[2]);
combcircuit c4(load ,datain[3] ,dataout[3]  ,w[3]);
flipflop    f4(clk  ,clr   ,w[3]      ,dataout[3]);

endmodule

module tb;

reg  clk ,clr ,load;
reg  [3:0] datain;
wire [3:0] dataout;

buffercontroller dut(clk ,clr ,load ,datain ,dataout);

always #5 clk = ~clk;

initial
begin
clk    = 1'b0;
clr    = 1'b0;
load   = 1'b1;
#6
clr    = 1'b1;
#9;
datain = 4'b1111;
#10;
load   = 1'b0;
datain = 4'b1010;
#20
load   = 1'b1;
datain = 4'b1010;

end

endmodule

51) HDLBITS(https://hdlbits.01xz.net/wiki/Exams/2014_q3bfsm)

module top_module(clk ,reset ,x ,z);
    
    input clk ,reset ,x;
    output  z;
    
    parameter S0 = 4'b000 ,S1 = 4'b001 ,S2 = 4'b010 ,S3 = 4'b011 ,S4 = 4'b100;
    reg [2:0] ps ,ns;
    
    always @(posedge clk)
        begin
            if(reset)
                ps <= S0;
            else
                ps <= ns;
            
        end
    
    always @(ps ,x)
        case(ps)
            S0 : ns = x ? S1 : S0;
            S1 : ns = x ? S4 : S1;
            S2 : ns = x ? S1 : S2;
            S3 : ns = x ? S2 : S1;
            S4 : ns = x ? S4 : S3;
        endcase
    
    assign z = (ps == S3 || ps == S4) ? 1'b1 : 1'b0;
    
endmodule

52) Frequency Divider by 5 

module counter(clk ,rst ,out);

input clk ,rst;
output reg [2:0] out;

always @(posedge clk)
begin
if(rst)
out <= 3'b000;
else if(out == 3'b100)
out <= 3'b000;
else
out <= out + 1'b1;
end

endmodule

module flipflop(clk ,rst ,in ,out);

input clk ,rst ,in;
output reg out;

always @(negedge clk)
begin
if(rst)
out <= 1'b0;
else
out <= in;
end

endmodule

module divider(clk ,rst ,out);

input clk ,rst;
output out;

wire [2:0] w;
wire w1;
counter  c1(clk ,rst ,w);
flipflop f1(clk ,rst ,w[1] ,w1);
or(out ,w[1] ,w1);

endmodule


module tb;

reg clk ,rst;
wire out;

divider dut(clk ,rst ,out);

always #5 clk = ~clk;

initial
begin
clk = 1'b0;
rst = 1'b1;
#11;
rst = 1'b0;
end

endmodule

53) Frequency Divider by 6

module FF(clk ,rst ,in ,out ,outbar);

input clk ,rst ,in;
output reg out ,outbar;

always @(posedge clk)
begin
if(rst)
begin
out    <= 1'b0;
outbar <= 1'b1;
end
else
begin
out    <= in;
outbar <= ~in;
end
end

endmodule

module frequencydividebysix(clk ,rst ,out);

input clk ,rst;
output out;

wire [2:0] outbar;
wire [1:0] out_put;

FF F1(clk ,rst ,outbar[2]  ,out_put[0] ,outbar[0]);
FF F2(clk ,rst ,out_put[0] ,out_put[1] ,outbar[1]);
FF F3(clk ,rst ,out_put[1] ,out        ,outbar[2]);

endmodule

module tb;

reg clk ,rst;
wire out;

frequencydividebysix dut(clk ,rst ,out);

always #5 clk = ~clk;

initial
begin
clk = 1'b0;
rst = 1'b1;
#6;
rst = 1'b0;
end

endmodule

54) fibonacci series

module fibonacci(clk ,rst ,out);

input clk ,rst;
output reg [7:0] out;
reg [7:0] help;

always @(posedge clk)
begin
if(rst)
begin
out  <= 8'b0000_0000;
help <= 8'b0000_0001;
end
else
begin
out  <= out + help;
help <= out;
end
end

endmodule

module tb;

reg clk ,rst;
wire [7:0] out;

fibonacci dut(clk ,rst ,out);

always #5 clk = ~clk;

initial
begin
clk = 1'b0;
rst = 1'b1;
#6;
rst = 1'b0;
end

initial
begin
#80;
$finish();
end
endmodule

55) Factorial of a number

module fact(clk ,rst ,number ,factorialofnumber);

input  clk ,rst;
input  [3:0] number;
output reg [31:0] factorialofnumber;

parameter idle = 3'b0001 ,checker = 3'b010 ,operation = 3'b100 ,result = 3'b000;
reg [2:0]  ps ,ns;
reg [31:0]  num ,tempnum ,capture;
reg [31:0] count;
reg [31:0] sum;


always @(posedge clk)
begin
if(rst)
ps <= idle;
else
ps <= ns;
end

always @(ps ,num ,count ,number)
begin
case(ps)
idle      : ns = (number == 0 || number == 1) ? result : checker;
checker   : ns = (num == 4'b0001) ? result : operation;
operation : ns = (count == 1) ? checker : operation;
result    : ns = result;
endcase
end

always @(posedge clk)
begin
if(rst)
begin
num               <= number - 1;
tempnum           <= number;
count             <= 32'b00000000000000000000000000000000;
sum               <= 32'b00000000000000000000000000000000;
capture           <= 32'b00000000000000000000000000000000;
end
else if(ps == checker)
begin
count             <= num;
capture           <= tempnum;
factorialofnumber <= sum;
sum               <= 32'b00000000000000000000000000000000;
end
else if(ps == operation)
begin
if(count != 0)
begin
sum   <= sum + tempnum;
count <= count - 1;
if(count == 1)
begin
tempnum <= sum + capture;
num     <= num - 1;
end
end
end
else if(ps == result)
begin
if(number == 0 || number == 1)
factorialofnumber <= 1;
end
end

endmodule

module tb;

reg  clk ,rst;
reg  [3:0] number;
wire [31:0] factorialofnumber;

fact dut(clk ,rst ,number ,factorialofnumber);

always #5 clk = ~clk;

initial
begin
clk = 1'b0;
rst = 1'b1;
number = 4'b0111;
#6
rst = 1'b0;
end

endmodule

56) Write code for following pattern
    0000_0001 ,0001_0000 ,0000_0001 ,0010_0000 ,0000_0001 ,0100_0000 ,0000_0001 ,1000_0000 and repeat

module pattern(clk ,rst ,out);

input clk ,rst;
output reg [7:0] out;
reg [3:0] temp;
reg check;

always @(posedge clk)
begin
if(rst)
begin
out   <= 8'b0000_0001;
temp  <= 4'b0100;
check <= 1'b1;
end
else
begin
out   <= check & 1'b1 ? (out[7] ? 8'b0000_0001 : out << temp) : (out[7] ? 8'b0000_0001 : out >> temp);
temp  <= check & 1'b1 ? temp : ((temp[2] & temp[1] & temp[0]) ? 4'b0100:temp + 1'b1);
check <= ~check;
end
end

endmodule

module tb;

reg clk ,rst;
wire [7:0] out;

pattern dut(clk ,rst ,out);

always # 5 clk = ~clk;

initial
begin
clk = 1'b0;
rst = 1'b1;
#6;
rst = 1'b0;
end

endmodule

57) A finite state machine has one input and one output. The output becomes 1 and remains 1 thereafter 
when at least two 0's and two 1's have occurred as inputs, regardless of the order of appearance.

module orderone(clk ,rst ,in ,out);

input clk ,rst ,in;
output out;

parameter S0 = 4'b0000 ,S1 = 4'b0001 ,S2 = 4'b0010 ,S3 = 4'b0011 ,S4 = 4'b0101 ,S5 = 4'b0110 ,S6 = 4'b0111 ,S7 = 4'b1000 ,S8 = 4'b0100;
reg [3:0] ps ,ns;

always @(posedge clk)
begin
if(rst)
ps <= S0;
else
ps <= ns;
end

always @(ps ,in)
begin
case(ps)
S0 : ns = in ? S4 : S1;
S1 : ns = in ? S8 : S2;
S2 : ns = in ? S3 : S2;
S3 : ns = in ? S5 : S3;
S4 : ns = in ? S6 : S8;
S5 : ns = S5;
S6 : ns = in ? S6 : S7;
S7 : ns = in ? S7 : S5;
S8 : ns = in ? S7 : S3;
endcase
end

assign out = (ps == S5) ? 1'b1 : 1'b0;

endmodule

module tb;

reg clk ,rst ,in;
wire out;

orderone dut(clk ,rst ,in ,out);

always #5 clk = ~clk;

initial
begin
clk = 1'b0;
rst = 1'b1;
in  = 1'b0;
#6;
rst = 1'b0;
#9;
in  = 1'b1;
#10;
in  = 1'b1;
#10;
in  = 1'b1;
#10;
in  = 1'b1;
#10;
in  = 1'b0;

end

endmodule

58) DICE GAME
The player will guess a number between 1 and 6 and enter it as a binary number in the "dice_guess" input of the 
main module.The player will hold the dice for a random time length (set to 1 the "roll_dice" input).During this 
time, the electronic dice will roll through the 6 numbers of the dice over and over.The player will then release
(set to 0) the "roll_dice" input which will cause the dice to stop rolling. At this point, the "dice_output" 
should stop on a number between 1 and 6 (just like a real dice). If the number displayed by the dice is the same
as the number the player entered, the output will be win = 1 and lose = 0. If the "dice_guess" is different than
the "dice_output", then the output will show win = 0 and lose = 1.To start another game, the player must set 
reset to 1 for at least one clock cycle and then back to 0, then enter a new guess number, and roll the dice again.


module dice(clk ,rst ,dice_guess ,roll_dice ,dice_output ,win ,lose);

input clk ,rst ,roll_dice;
input [2:0] dice_guess;
output reg win ,lose;
output reg [2:0] dice_output;

always @(posedge clk)
begin
if(rst)
begin
dice_output <= 3'b000;
win         <= 1'b0;
lose        <= 1'b0;
end
else
begin
if(~(&dice_guess) && roll_dice == 1'b1)
dice_output <= {$random} % 6;
else if(roll_dice == 1'b0)
begin
if(dice_guess == dice_output)
begin
win  <= 1'b1;
lose <= 1'b0;
end
else
begin
win  <= 1'b0;
lose <= 1'b1;
end
end
end
end
  
endmodule

module tb;
  
  reg clk ,rst ,roll_dice;
  reg [2:0] dice_guess;
  wire win ,lose;
  wire [2:0] dice_output;
  
  always #5 clk = ~clk;
  
  dice dut(clk ,rst ,dice_guess ,roll_dice ,dice_output ,win ,lose);
  
  initial
    begin
      clk = 1'b0;
      rst = 1'b1;
      #6;
      rst = 1'b0;
      #9;
      dice_guess = 5;
      roll_dice  = 1'b1;
      #40;
      roll_dice  = 1'b0;
      
    end
  
  initial begin
  $dumpfile("dump.vcd");
  $dumpvars;
  #10000 
  $finish;
end
  
endmodule

59) Design a moore FSM state with one input A and output X and Y. X should be 1 if A has been 1 for at least three clock cycle 
altogther(not neccesaly consecutively). Y should be 1 if A has been 1 for at least two consecutively clock cycle.

module fsmdesign(clk ,rst ,IN ,X ,Y);

input clk ,rst ,IN;
output X ,Y;

parameter A = 4'b0000 ,B = 4'b0001 ,C = 4'b0010 ,D = 4'b0011 ,E = 4'b0100 ,F = 4'b0101 ,G = 4'b0110 ,H = 4'b0111 ,I = 4'b1000;
reg [3:0] ps ,ns;

always @(posedge clk)
begin
if(rst)
ps <= A;
else
ps <= ns;
end

always @(ps ,IN)
begin
case(ps)
A : ns = IN ? B : A;
B : ns = IN ? C : F;
C : ns = IN ? D : G;
D : ns = IN ? D : E;
E : ns = IN ? H : E;
F : ns = IN ? I : F;
G : ns = IN ? H : G;
H : ns = IN ? D : E;
I : ns = IN ? D : G; 
endcase
end

assign X = (ps == D || ps == H || ps == E) ? 1'b1 : 1'b0;
assign Y = (ps == D || ps == C) ? 1'b1 : 1'b0;


endmodule

module tb;

reg clk ,rst ,IN;
wire X ,Y;

fsmdesign dut(clk ,rst ,IN ,X ,Y);

always #5 clk = ~clk;

initial
begin
clk = 1'b0;
rst = 1'b1;
IN  = 1'b0;
#6;
rst = 1'b0;
#9;
IN  = 1'b0;
#10;
IN  = 1'b1;
#10;
IN  = 1'b0;
#10;
IN  = 1'b1;
#10;
IN  = 1'b1;
#10;
IN  = 1'b1;
#10;
IN  = 1'b1;

end

endmodule

60) FIZZBUZZ GAME
     Rules of the game:
     If the number is a multiple of the 5 and not a multiple of 7, you will make Fizz port high
     If the number is a multiple of the 7 and not a multiple of 5, you will make Buzz port high
     If the number is a multiple of the 7 and 5, you will make FizzBuzz port high
     Otherwise, you will make all flag ports low

module fizzbuzz(clk ,rst ,data ,fizz ,buzz ,fizzbuzz);

input clk ,rst;
input [7:0] data;
output reg fizz ,buzz ,fizzbuzz;

reg [7:0] five ,seven;

always @(posedge clk)
begin
if(rst)
begin
five  <= 8'b0000_0000;
seven <= 8'b0000_0000;
end
else
begin
if(five == data && seven == data)
fizzbuzz <= 1'b1;
else if(five == data && seven > data)
fizz <= 1'b1;
else if(five > data && seven == data)
buzz <= 1'b1;
else if(five < data && seven >= data)
five <= five + 8'b0000_0101;
else if(five >= data && seven < data)
seven <= seven + 8'b0000_0111;
else if(five < data && seven < data)
begin
five  <= five  + 8'b0000_0101;
seven <= seven + 8'b0000_0111;
end
else
begin
fizz     <= 1'b0;
buzz     <= 1'b0;
fizzbuzz <= 1'b0;
end
end
end

endmodule


module tb;

reg clk ,rst;
reg [7:0] data;
wire fizz ,buzz ,fizzbuzz;

fizzbuzz dut(clk ,rst ,data ,fizz ,buzz ,fizzbuzz);

always #5 clk = ~clk;

initial
begin
clk = 1'b0;
rst = 1'b1;
#6 
rst = 1'b0;
#9
data = 63;
end

endmodule

61) A sequential circuit has two inputs and two outputs. The inputs X1 and X2 represent a 2-
bit unsigned binary number denoted by N. Here, X1 is most significant bit of N, and X2 is
the least significant bit of N. The outputs are denoted by Z1, Z2. If the present value of N
is greater than the previous value, then Z1 is 1. If the present value of N is less than the
previous value, then Z2 is 1. Otherwise, Z1 and Z2 are 0. When the first pair of inputs is
received, there is no previous value of N, so we cannot determine whether the present N
is greater than or less than the previous value; therefore, the “otherwise” category applies,
i.e. both Z1and Z2 are 0.
Z = [Z1 ,Z2]
NOTE :- NOT USE ">" ,"<" ,"==" operater HINT :- FSM

module camparefsm(clk ,rst ,X ,Z);

input clk ,rst;
input [1:0] X;
output reg [1:0] Z;

parameter A = 4'b0000 ,zerozero = 4'b0001 ,zeroone = 4'b0010 ,onezero = 4'b0100 ,oneone = 4'b1000;
reg [3:0] ps ,ns;

always @(posedge clk)
begin
if(rst)
ps <= A;
else
ps <= ns;
end

always @(ps ,X)
begin
case(ps)
A        : begin
ns = X[1] ^ X[0] ? (X[1] ? onezero : zeroone) : (X[1] ? oneone : zerozero);
Z  = 2'b00;
end
zerozero : begin
ns = X[1] ^ X[0] ? (X[1] ? onezero : zeroone) : (X[1] ? oneone : zerozero);
Z  = X[1] ^ X[0] ? 2'b10 : (X[1] ? 2'b10 : 2'b00);
end
zeroone  : begin
ns = X[1] ^ X[0] ? (X[1] ? onezero : zeroone) : (X[1] ? oneone : zerozero);
Z  = X[1] ^ X[0] ? (X[1] ? 2'b10 : 2'b00) : (X[1] ? 2'b10 : 2'b01);
end
onezero  : begin
ns = X[1] ^ X[0] ? (X[1] ? onezero : zeroone) : (X[1] ? oneone : zerozero);
Z  = X[1] ^ X[0] ? (X[1] ? 2'b00 : 2'b01) :(X[1] ? 2'b10 : 2'b01); 
end
oneone   : begin
ns = X[1] ^ X[0] ? (X[1] ? onezero : zeroone) : (X[1] ? oneone : zerozero);
Z  = X[1] ^ X[0] ? 2'b01  : (X[1] ? 2'b00 : 2'b01);
end
endcase
end

endmodule

module tb;

reg clk ,rst;
reg [1:0] X;
wire [1:0] Z;

camparefsm dut(clk ,rst ,X ,Z);

always #5 clk = ~clk;

initial
begin
clk = 1'b0;
rst = 1'b1;
X = 2'b00;
#6
rst = 1'b0;
#9
X = 2'b10;
#10;
X = 2'b00;
#10;
X = 2'b10;
#10;
X = 2'b11;
#10;
X = 2'b10;
#10;
X = 2'b01;
#10;
X = 2'b10;
end

endmodule

62) Chech wheather input in present cycle is same as previous cycle using FSM.If input in present
cycle is same as previous cycle then output is 1 else output is 0

module samecycle(clk ,rst ,in ,out);

input clk ,rst ,in;
output  out;

parameter A = 4'b0000 ,B = 4'b0001 ,C = 4'b0010 ,D = 4'b0100 ,E = 4'b1000;
reg [3:0] ps ,ns;

always @(posedge clk)
begin
if(rst)
ps <= A;
else
ps <= ns;
end

always @(ps ,in)
begin
case(ps)
A : ns = in ? B : D;
B : ns = in ? C : D;
C : ns = in ? C : D;
D : ns = in ? B : E;
E : ns = in ? B : E;
endcase
end

assign out = (ps == C || ps == E) ? 1'b1 : 1'b0; 

endmodule

module tb;

reg clk ,rst ,in;
wire  out;

samecycle dut(clk ,rst ,in ,out);

always #5 clk = ~clk;

initial
begin
clk = 1'b0;
rst = 1'b1;
in  = 1'b0;
#6
rst = 1'b0;
#9
in  = 1'b1;
#10
in  = 1'b0;
#10
in  = 1'b1;
#10
in  = 1'b0;
#10
in  = 1'b1;
#10
in  = 1'b0;
#10
in  = 1'b1;
#10
in  = 1'b1;
#10
in  = 1'b0;
#10
in  = 1'b0;
#10
in  = 1'b1;
end

endmodule

63) Find the determinant of 2 X 2 matrix.

Note - ALL THE INPUT SHOULD BE POSTIVE BUT OUTPUT CAN BE NEGATIVE

module determinant(matrix ,result);

input [3:0] matrix [0:1][0:1];
output signed [7:0]result;

assign result = matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];

endmodule

module tb;
  
  reg [3:0] matrix [0:1][0:1];
  wire signed [7:0]result;
  
  determinant dut(matrix ,result);
  
  initial
    begin
      matrix[0][0] = 8;
      matrix[0][1] = 5;
      matrix[1][0] = 5;
      matrix[1][1] = 5;
    end
  
endmodule

64) Restoring Division Algorithm For 4 Bit Unsigned Integer

module restoring(clk ,rst ,divisor ,dividend ,remainder ,Quotient);

input clk ,rst;
input [3:0] divisor ,dividend;
output [3:0] remainder ,Quotient;

parameter idle = 4'b0000 ,shift_operation = 4'b0001 ,add = 4'b0010 ,check_one = 4'b0100 ,substract = 4'b1000 ,check_two = 4'b1100 ,result = 4'b0011;
reg [3:0] ps ,ns;
reg [3:0] n;
reg [4:0] m ,store_a;
reg [8:0] shift_aq;


always @(posedge clk)
begin
if(rst)
ps <= idle;
else
ps <= ns;
end

always @(ps ,divisor ,dividend ,n)
begin
case(ps)
idle            : ns = shift_operation;
shift_operation : ns = add;
add             : ns = check_one;
check_one       : ns = substract;
substract       : ns = check_two;
check_two       : ns = (n == 1'b0) ? result : shift_operation;
result          : ns = result;
endcase
end

always @(posedge clk)
begin
if(ps == idle)
begin
n <= 4'b0100;
shift_aq <= {5'b0000 ,dividend};
m <= {1'b1,~divisor[3] ,~divisor[2] ,~divisor[1] ,~divisor[0]} + 1'b1;
end
else if(ps == shift_operation)
shift_aq <= shift_aq << 1'b1;
else if(ps == add)
begin
store_a       <= shift_aq[8:4];
shift_aq[8:4] <= shift_aq[8:4] + m;
end
else if(ps == check_one)
begin
if(shift_aq[8] == 1'b1)
begin
shift_aq[0]   <= 1'b0;
shift_aq[8:4] <= store_a;
end
else
shift_aq[0] <= 1'b1;
end
else if(ps == substract)
n <= n - 1;
end

assign remainder = (ps == result) ? shift_aq[8:4] : 4'b0000;
assign Quotient  = (ps == result) ? shift_aq[3:0] : 4'b0000;

endmodule

module tb;

reg clk ,rst;
reg [3:0] divisor ,dividend;
wire [3:0] remainder ,Quotient;

restoring dut(clk ,rst ,divisor ,dividend ,remainder ,Quotient);

always #5 clk = ~clk;

initial
begin
clk = 1'b0;
rst = 1'b1;
#6;
rst = 1'b0;
#9;
dividend = 4'b1110;
divisor  = 4'b0010;
end

endmodule

65) DECIMAL TO AIKEN CODE 

module aiken(in ,out);

input  [3:0] in;
output reg [3:0] out;

always @(*)
begin
case(in)
4'b0000 : out = 4'b0000;
4'b0001 : out = 4'b0001;
4'b0010 : out = 4'b0010;
4'b0011 : out = 4'b0011;
4'b0100 : out = 4'b0100;
4'b0101 : out = 4'b1011;
4'b0110 : out = 4'b1100;
4'b0111 : out = 4'b1101;
4'b1000 : out = 4'b1110;
4'b1001 : out = 4'b1111;
default : out = 4'bxxxx;
endcase
end

endmodule

module tb;

reg  [3:0] in;
wire [3:0] out;

aiken dut(in ,out);

initial
begin
in = 0;
#10;
in = 1;
#10;
in = 2;
#10;
in = 3;
#10;
in = 4;
#10;
in = 5;
#10;
in = 6;
#10;
in = 7;
#10;
in = 8;
#10;
in = 9;
#10;
in = 10;
#10;
end

endmodule

66) Cs450/timer(https://hdlbits.01xz.net/wiki/Cs450/timer)

module top_module(clk ,load ,data ,tc);
    
    input clk ,load;
    input [9:0] data;
    output tc;
    
    reg [9:0] counter;
    
    always @(posedge clk)
        begin
            if(load)
                begin
                    counter <= data;
                    if(data == 0)
                        tc <= 1'b1;
                    else
                        tc <= 1'b0;
                end
            else
                begin
                    if(counter == 0)
                        begin
                            counter <= counter;
                            tc <= 1'b1;
                            
                        end
                    else
                        begin
                            counter <= counter - 10'b0000000001;
                            if (counter == 1)
                                tc <= 1'b1;
                        end
                       
                end
        end
    
    
endmodule

67) Cs450/counter 2bc(https://hdlbits.01xz.net/wiki/Cs450/counter_2bc#cite_note-1)

module top_module(clk ,areset ,train_valid ,train_taken ,state);
    
    input clk ,areset ,train_valid ,train_taken;
    output [1:0] state;
    
    parameter snt = 2'b00 ,wnt = 2'b01 ,wt = 2'b10 ,st = 2'b11;
    reg [1:0] ps ,ns;
    
    always @(posedge clk or posedge areset)
        begin
            if(areset)
                ps <= wnt;
            else
                ps <= ns;
        end
    
    always @(ps ,train_valid ,train_taken)
        begin
            case(ps)
                snt : ns = train_valid & train_taken ? wnt : (train_valid ? snt : snt);
                wnt : ns = train_valid & train_taken ? wt  : (train_valid ? snt : wnt);
                wt  : ns = train_valid & train_taken ? st  : (train_valid ? wnt : wt);
                st  : ns = train_valid & train_taken ? st  : (train_valid ? wt  : st);
            endcase
        end
    
    assign state = ps;
    
endmodule

68) Cs450/history shift(https://hdlbits.01xz.net/wiki/Cs450/history_shift)

module top_module(clk ,areset ,predict_valid, predict_taken, predict_history ,train_mispredicted 
                  ,train_taken, train_history);
    
    input clk ,areset ,predict_valid, predict_taken ,train_mispredicted ,train_taken;
    input [31:0] train_history;
    output reg [31:0] predict_history;
    
    always @(posedge clk or posedge areset) 
        begin
            if(areset)
                predict_history <= 32'b00000000000000000000000000000000;
            else
                begin
                    if(predict_valid == 1 && train_mispredicted == 1)
                        predict_history <= {train_history[30:0] ,train_taken};
                    else if(predict_valid == 1)
                        predict_history <= {predict_history[30:0] ,predict_taken};
                    else if(train_mispredicted == 1)
                        predict_history <= {train_history[30:0] ,train_taken};
                    else
                        predict_history <= predict_history;
                end
        end
    
endmodule

69) Countbcd(https://hdlbits.01xz.net/wiki/Countbcd)

module counter(clk ,rst ,enable ,out );
    
    input clk ,rst ,enable;
    output [3:0] out;
    
    always @(posedge clk)
        begin
            if(rst)
                out <= 4'b0000;
            else if(enable == 1'b1)
                begin
                    if(out == 4'b1001)
                        out <= 4'b0000;
                    else
                        out <= out + 1'b1;
                end
            else
                out <= out;
        end
    
endmodule

module top_module(clk ,reset ,ena ,q);
    
    input clk ,reset;
    output reg [3:1] ena;
    output [15:0] q;
    wire e;
    
    counter threezero(clk ,reset ,e ,q[3:0]);
    counter sevenfour(clk ,reset ,ena[1] ,q[7:4]);
    counter eleveneight(clk ,reset ,ena[2] ,q[11:8]);
    counter fifteentwelve(clk ,reset ,ena[3] ,q[15:12]);
    
 
    assign e = 1'b1;
    assign ena[1] = e && q[3:0] == 4'b1001 ? 1'b1 : 1'b0;
    assign ena[2] = ena[1] && q[7:4] == 4'b1001 ? 1'b1 : 1'b0;
    assign ena[3] = ena[2] && q[11:8] == 4'b1001 ? 1'b1 : 1'b0;
                                         
endmodule

70) Count number of one's in a binary vector using adders

module fulladder(a ,b ,cin ,cout ,sum);

input a ,b ,cin;
output cout ,sum;

assign sum = a ^ b ^ cin;
assign cout = a & b | b & cin | a & cin;

endmodule

module countone(in ,out);

input [6:0] in;
output [2:0] out;
wire [2:0] sum ,cout;

fulladder FA1(in[6]    ,in[5]   ,in[4]   ,cout[0]  ,sum[0]);
fulladder FA2(in[3]    ,in[2]   ,in[1]   ,cout[1]  ,sum[1]);
fulladder FA3(cout[0]  ,cout[1] ,cout[2] ,out[2]   ,out[1]);
fulladder FA4(sum[0]   ,sum[1]  ,in[0]   ,cout[2]  ,out[0]);

endmodule

module tb;

reg [6:0] in;
wire [2:0] out;

countone dut(in ,out);

initial
begin
in = 7'b1111000;
#10;
in = 7'b0101010;
#10;
in = 7'b0001111;
#10;
in = 7'b1000001;
#10;
in = 7'b0011001;
#10;
in = 7'b1111111;
#10;
in = 7'b0000000;
#10;
in = 7'b1110111;
end

endmodule

71) BUBBLE SORT

module bubble(clk ,rst ,in1 ,in2 ,in3 ,in4 ,in5 ,out1 ,out2 ,out3 ,out4 ,out5 ,len);

input clk ,rst;
input [3:0] len;
input [7:0] in1 ,in2 ,in3 ,in4 ,in5;
output [7:0] out1 ,out2 ,out3 ,out4 ,out5;

reg [7:0] mem [4:0];
parameter idle = 4'b0000 ,check = 4'b0001 ,campare = 4'b0010 ,swap = 4'b0100 ,change = 4'b1000 ,stop = 4'b1111;
reg [3:0] ps ,ns;
reg [3:0] i ,j ,count;

always @(posedge clk)
begin
if(rst)
ps <= idle;
else
ps <= ns;
end

always @(ps ,len ,mem ,i ,j ,count)
begin
case(ps)
idle    : ns = campare;
check   : ns = (i + 1'b1 >= j) ? change : campare ;
campare : ns = i < 4'b0100 ? (mem[i] > mem[i+1] ? swap : (count >= j - 1) ? stop : check) : ((count >= j - 1) ? stop : check); 
swap    : ns = check;
change  : ns = campare;
stop    : ns = stop;
endcase
end

always @(posedge clk)
begin
if(rst)
begin
j      <= len;
i      <= 4'b0000;
count  <= 4'b0000;
mem[0] <= in1;
mem[1] <= in2;
mem[2] <= in3;
mem[3] <= in4;
mem[4] <= in5;
end
else if(ps == check)
begin
i <= i + 1'b1;
end
else if(ps == campare)
begin
count <= count + 1'b1;
end
else if(ps == change)
begin
i     <= 4'b0000;
count <= 4'b0000;
end
else if(ps == swap)
begin
mem[i]     <= mem[i + 1];
mem[i + 1] <= mem[i];
count      <= count - 1'b1;
end
end

assign out1 = (ps == stop) ? mem[0] : 8'b00000000;
assign out2 = (ps == stop) ? mem[1] : 8'b00000000;
assign out3 = (ps == stop) ? mem[2] : 8'b00000000;
assign out4 = (ps == stop) ? mem[3] : 8'b00000000;
assign out5 = (ps == stop) ? mem[4] : 8'b00000000;

endmodule


module tb;

reg clk ,rst;
reg [3:0] len;
reg [7:0] in1 ,in2 ,in3 ,in4 ,in5;
wire [7:0] out1 ,out2 ,out3 ,out4 ,out5;

bubble dut(clk ,rst ,in1 ,in2 ,in3 ,in4 ,in5 ,out1 ,out2 ,out3 ,out4 ,out5 ,len);

always #5 clk = ~clk;

initial
begin
clk = 1'b0;
rst = 1'b1;
in1 = 22;
in2 = 22;
in3 = 22;
in4 = 4;
in5 = 22;
len = 4'b0101;
#6;
rst = 1'b0;
end

endmodule







            
          




















  
































    

    

    

			 




















































